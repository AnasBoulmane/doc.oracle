<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Dynamo/Client/Store/web/store.war/shared/js/pageLayout/cart.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Dynamo/Client/Store/web/store.war/shared/js/pageLayout/cart.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @fileoverview Defines a CartViewModel used to represent and maintain the
 * shopping cart for the site.
 *
 */

/*global define */
define(
  //-------------------------------------------------------------------
  // PACKAGE NAME
  //-------------------------------------------------------------------
  'pageLayout/cart',

  //-------------------------------------------------------------------
  // DEPENDENCIES
  //-------------------------------------------------------------------
  ['knockout', 'pubsub', 'notifier', 'notifications', 'storeKoExtensions',
    'CCi18n', 'ccLogger', 'ccNumber', 'jquery', 'ccConstants', 'navigation',
    'storageApi', 'pageLayout/site', 'viewModels/dynamicProperty', 'currencyHelper', 'ccRestClient',
    'viewModels/shippingMethodItemViewModel', 'koMapping'],

  //-------------------------------------------------------------------
  // MODULE DEFINITION
  //-------------------------------------------------------------------
  function (ko, pubsub, notifier, notifications, storeKoExtensions, CCi18n,
      log, ccNumber, $, ccConstants, navigation, storageApi, SiteViewModel, 
      DynamicProperty, currencyHelper, ccRestClient, ShippingMethodItemViewModel, koMapping) {

    "use strict";

    var CART_EVENT_ADD = 1;
    var CART_EVENT_UPDATE = 2;
    var CART_EVENT_DELETE = 3;
    var CART_EVENT_COUPON_ADD = 4;
    var CART_EVENT_COUPON_DELETE = 5;
    var CART_EVENT_GIFTCARD_ADD = 6;
    var CART_EVENT_GIFTCARD_DELETE = 7;
    var CART_EVENT_GIFTCARD_REAPPLY = 8;
    var CART_EVENT_REPRICE = 9;

    var CART_VIEW_MODEL_ID = "CartViewModel";
    var GIFT_WITH_PURCHASE_ID = "GiftWithPurchase";

    var application = ccConstants.APPLICATION_STOREFRONT;

    //------------------------------------------------------------------
    // Class definition &amp; member variables
    //------------------------------------------------------------------
    /**
     * Creates a cart view model. The CartViewModel is used to represent and maintain the cart for
     * the site. CartViewModel is a singleton and you can use 'getInstance' to access it.
     *
     * CartViewModel holds a list of cart events with the following types defined:
     *
     * &lt;ul>
     *  &lt;li>&lt;b>CART_EVENT_ADD=1&lt;/b> - Cart Event type representing an added item.&lt;/li>
     *  &lt;li>&lt;b>CART_EVENT_UPDATE=2&lt;/b> - Cart Event type representing update to cart.&lt;/li>
     *  &lt;li>&lt;b>CART_EVENT_DELETE=3&lt;/b> - Cart Event type representing a deleted item.&lt;/li>
     *  &lt;li>&lt;b>CART_EVENT_COUPON_ADD=4&lt;/b> - Cart Event type representing a coupon code added to cart.&lt;/li>
     *  &lt;li>&lt;b>CART_EVENT_COUPON_DELETE=5&lt;/b> - Cart Event type representing a coupon code being removed from cart.&lt;/li>
     *  &lt;li>&lt;b>CART_EVENT_GIFTCARD_ADD=6&lt;/b> - Cart Event type representing a gift card being added to cart.&lt;/li>
     *  &lt;li>&lt;b>CART_EVENT_GIFTCARD_DELETE=7&lt;/b> - Cart Event type representing a gift card being removed from cart.&lt;/li>
     * &lt;/ul>
     *
     * @public
     * @class Shopping cart view model.
     * @name CartViewModel
     * @property {RestAdapter} adapter An adapter used to make the REST calls.
     * @property {UserViewModel} user Internal reference to user view model.
     * @property {observableArray&lt;CartItem>} items List of items in the cart.
     * @property {observableArray&lt;Object>} coupons List of coupons added to cart.
     * @property {observable&lt;number>} numberOfItems Number of items in the cart.
     * @property {observable&lt;number>} total Total value of cart including items, tax and shipping modifications.
     * @property {observable&lt;number>} totalWithoutTax total value minus the tax.
     * @property {observable&lt;number>} subTotal Total value of items in cart.
     * @property {observable&lt;number>} tax Tax calculated for cart.
     * @property {observable&lt;number>} shipping Shipping cost of cart.
     * @property {observable&lt;number>} shippingDiscount Shipping discount applied to cart.
     * @property {observable&lt;number>} shippingSurcharge Shipping surcharge applied to cart.
     * @property {observable&lt;number>} orderDiscount Discounts applied to items in cart.
     * @property {observable&lt;string>} shippingMethod Currently selected shipping method.
     * @property {observable&lt;string>} shippingAddress Currently selected shipping address, cached in case
     *   anonymous users leave the checkout page. Will be overridden by user's default shipping address if
     *   available.
     * @property {observable&lt;string>} catalogId ID of the catalog for the item
     * @property {observable&lt;string>} currencyCode Code of currency used for prices and discounts.
     * @property {observable&lt;boolean>} isDirty true if the cart has unsaved changes.
     * @property {observable&lt;boolean>} isPricingRequired true if the cart needs it's cost totals updated.
     * @property {observable&lt;boolean>} skipPriceChange true will cause the cart to skip the next price change.
     * @property {observable&lt;boolean>} checkoutWithPaypalClicked true if paypal checkout has been activated.
     * @property {observable&lt;boolean>} isMatchingCookieData true if the cart state matches the state of the saved cookie.
     * @property {observableArray&lt;GiftCardViewModel>} giftCards Array of gift cards
     * @property {observableArray&lt;DynamicProperty>} dynamicProperties Array of dynamic properties
     *  
     * @property {observable&lt;boolean>} validateAndRedirectCart true will cause cart validation and redirection to
     *   either the edit cart page (if invalid) or checkout page (if valid).
     * @property {observable&lt;boolean>} updateFromRepository true if we need to fetch updated data from the server.
     * @property {observable&lt;string>} orderDiscountDescList List of descriptions for any order discounts
     *   applied to cart.
     * @property {observable&lt;string>} couponErrorMessage Localised message to display if there is an error with a coupon.
     * @property {string[]} invalidProductNames List of names considered invalid.
     * @property {observableArray&lt;string>} errors List of errors logged against the cart.
     * @property {Object} giftWithPurchaseOrderMarkers Contains any gwp order marker information.
     * @property {observableArray&lt;Object>} placeHolderItems List of place holder items in the cart.
     * @property {observable&lt;boolean>} isSplitShipping The property that indicates if split shipping is activated.
     *    When the user selects split shipping this property must be set to true. It is also this property that 
     *    should be used to control the visibility of split/single shipping UI elements.
     * @property {observableArray&lt;Object>} orderShippingGroups The latest shipping groups array (if any) returned from
     *    a web service call.
     */
    function CartViewModel(pAdapter, pShoppingCartData, pUser, pContext) {

      if (CartViewModel.singleInstance) {
        throw new Error("Cannot instantiate more than one CartViewModel, use getInstance(pAdapter, pShoppingCartData)");
      }

      var self = this;

      self.currency = SiteViewModel.getInstance().selectedPriceListGroup().currency;
      self.user = pUser;
      self.isDirty = ko.observable(false);
      self.callPriceBeforeShippingMethods = false;
      self.updatedFromRepository = false;
      self.adapter = pAdapter;
      self.errors = ko.observableArray([]);
      self.items = ko.observableArray([]);
      self.allItems = ko.observableArray([]); // This variable will hold place holder and cart items.
      self.coupons = ko.observableArray([]);
      self.couponMultiPromotions = ko.observableArray([]);
      self.claimedCouponMultiPromotions = ko.observableArray([]);
      self.numberOfItems = ko.observable(0);
      self.total = ko.observable(0);
      self.totalWithoutTax = ko.observable(0);
      self.subTotal = ko.observable(0);
      self.amount = ko.observable(0);
      self.tax = ko.observable(0);
      self.shipping = ko.observable(0);
      self.shippingDiscount = ko.observable(0);
      self.currencyCode = ko.observable('');
      self.shippingMethod = ko.observable('');
      self.catalogId = ko.observable('');
      self.shippingAddress = ko.observable('');
      self.shippingSurcharge = ko.observable(0);
      self.updatedProduct = ko.observable('');
      self.validateAndRedirectCart = ko.observable(false);
      self.orderDiscount = ko.observable(0);
      self.orderDiscountDescList = ko.observableArray([]);
      self.couponErrorMessage = ko.observable();
      self.skipPriceChange = ko.observable(false);
      self.isPricingRequired = ko.observable(false);
      self.invalidProductNames = [];
      self.checkoutWithPaypalClicked = ko.observable(false);
      self.isMatchingCookieData = ko.observable(false);
      self.giftCards = ko.observableArray([]);
      self.dynamicProperties = ko.observableArray([]);
      self.cartPriceListGroupId = ko.observable();
      self.showSelectedOptions = ko.observable(false);
      self.isSplitShipping = ko.observable(false);
      self.orderShippingGroups = ko.observableArray();
      if(pContext &amp;&amp; pContext.global &amp;&amp; pContext.global.site &amp;&amp; pContext.global.site.extensionSiteSettings 
    		&amp;&amp; pContext.global.site.extensionSiteSettings.storeEndpointSettings 
    		&amp;&amp; pContext.global.site.extensionSiteSettings.storeEndpointSettings.cartFields)
    	self.fields = pContext.global.site.extensionSiteSettings.storeEndpointSettings.cartFields;

      self.callbacks = {};

      self.giftWithPurchaseOrderMarkers = [];
      self.gwpQualified = false;
      self.placeHolderItems = ko.observableArray([]);
      // In store, for logged-in user with shipping address, any operation on order results in two
      // pricing calls one after another. As GWP messages are sent only once, the second pricing call do
      // not contain the pricing messages.
      self.skipGWPMessage = false;

      // Marks the cart as having been changed
      self.markDirty = function() {
        if (!self.isDirty()) {
          self.isDirty(true);
        }
      };

      /**
       * Reset the Cart to a state of unmodified and save the contents to local storage.
       *
       * @private
       * @function
       * @name CartViewModel#cartUpdated
       */
      self.cartUpdated = function () {
        if (self.isDirty()) {
          self.isDirty(false);
        }
        self.saveCartCookie();
        // Callback to tell others the cart is ready
        $.Topic(pubsub.topicNames.CART_UPDATED).publish(self);
        self.updateAllItemsArray();
        if (self.validateAndRedirectCart()) {
          self.handleValidateCart();
        }
      };

      self.isDirty.subscribe(self.priceCartIfNeccessary.bind(self));

      /**
       * Registered for the add to cart growl notification's checkout button, to validate the cart and redirect.
       *
       * @private
       * @function
       * @name CartViewModel#handleValidateCart
       */
      self.handleValidateCart= function() {
        self.validatePrice = true;
        $.Topic(pubsub.topicNames.LOAD_CHECKOUT).publishWith(self, [{message: "success"}]);
      };

      /**
       * Update the contents of the cart, or update cart items based on the type of the most
       * recent cart event. Invoked on receiving a CART_PRICE_COMPLETE pubsub event.
       *
       * @private
       * @function
       * @name CartViewModel#updateCartItems
       */
      self.updateCartItems = function () {
        if (self.events.length > 0) {
          var data;
          var lastCartEvent = self.events.pop();
          self.events.push(lastCartEvent);
          switch (lastCartEvent.type) {
            case CART_EVENT_ADD :
              data = lastCartEvent.product;
              self.addItem(data);
              break;
            case CART_EVENT_UPDATE :
              data = lastCartEvent.product;
              self.updateItemQuantity(data);
              break;
            case CART_EVENT_DELETE :
              data = lastCartEvent.product;
              self.removeItemsByProduct(data.id);
              self.removeItem(data);
              break;
            case CART_EVENT_COUPON_DELETE :
              data = lastCartEvent.coupon;
              self.removeCouponFromCart(data);
              break;
            case CART_EVENT_COUPON_ADD :
              data = lastCartEvent.coupon;
              self.addCouponToCart(data);
              break;
          }
        }
      };

      /**
       * Adds a given item to the cart.
       *
       * @function
       * @name CartViewModel#addItem
       * @param {Object} data Object containing item data to create {CartItem} from.
       */
      self.addItem = function (data) {
        if (data &amp;&amp; data.childSKUs) {
          var productFound = false;
          var newQuantity;
          var cartItem = self.getCartItem(data.id, data.childSKUs[0].repositoryId);
          if (cartItem !== null) {
            newQuantity = cartItem.quantity() + data.orderQuantity;
            cartItem.quantity(newQuantity);
            // Add giftWithPurchaseSelections of the cart item
            if (data.giftProductData) {
              cartItem.giftWithPurchaseSelections = [
                {
                  "giftWithPurchaseIdentifier": data.giftProductData.giftWithPurchaseIdentifier,
                  "promotionId": data.giftProductData.promotionId,
                  "giftWithPurchaseQuantity": data.giftProductData.giftWithPurchaseQuantity
                }
              ];
            }
            productFound = true;
            // Notify successful quantity update.
            $.Topic(pubsub.topicNames.CART_UPDATE_QUANTITY_SUCCESS).publishWith(function() {[{message:"success"}];});
          }
          // If product is not in the cart then add it with the quantity set on the new product.
          if (!productFound) {
            newQuantity = data.orderQuantity;
            var productItem;
            if (data.externalPrice &amp;&amp; data.externalPriceQuantity) {
              productItem = new CartItem(
                  data.id, data, newQuantity, data.childSKUs[0].repositoryId, 
                  data.selectedOptions, self.currency, null, null, 
                  data.externalPrice, data.externalPriceQuantity);
            } else {
              productItem = new CartItem(
                  data.id, data, newQuantity, data.childSKUs[0].repositoryId, 
                  data.selectedOptions, self.currency);
            }
            self.items.push(productItem);
          }
          self.isDirty(false);
          self.markDirty();
        }
      };

      /**
       * Add item to the cart.
       *
       * @function
       * @name CartViewModel#addToCart
       */
      self.addToCart = function () {
        // If product to add is in the cart then simply increase the quantity.
        var cookieData = self.getCookieDataAndCompare();
        self.events.push(new CartEvent(CART_EVENT_ADD, 1, this));
        if (cookieData &amp;&amp; !self.isMatchingCookieData()) {
          self.getLocalData(cookieData);
          if (cookieData.items.length == 0) {
            self.addItem(this);
          }
        } else {
          self.addItem(this);
        }

      };
      //Subscription to update cart items after pricing complete.
      $.Topic(pubsub.topicNames.CART_PRICE_COMPLETE).subscribe(self.updateCartItems);

      /**
       * Remove the given item from the cart.
       *
       * @function
       * @name CartViewModel#removeFromCart
       */
      self.removeFromCart = function () {
        // Find the product in the cart items
        // If product to add is in the cart then simply increase the quantity.
        self.events.push(new CartEvent(CART_EVENT_DELETE, 0, this));
        var cookieData = self.getCookieDataAndCompare();
        if (cookieData &amp;&amp; cookieData.items.length > 0 &amp;&amp; !self.isMatchingCookieData()) {
          self.getLocalData(cookieData);
        } else {
          var cartItem = self.getCartItem(this.id, this.childSKUs[0].repositoryId);
          if (cartItem !== null) {
            self.removeItem(cartItem);
          }
        }
      };

      /**
       * Get cookie data and compare it with cart. Sets the flag 'isMatchingCookieData' if cookieData was
       * found for the cart.
       *
       * @private
       * @function
       * @name CartViewModel#getCookieDataAndCompare
       * @returns {Object} Cookie data
       */
      self.getCookieDataAndCompare = function () {
        var cookieData = self.getCookieData();
        if (cookieData) {
          self.isMatchingCookieData(self.compareItems(cookieData.items));
        }
        return cookieData;
      };



      /**
       * Extracted remove item functionality from above
       * so that it can also be called by updateQuantity
       * when the new quantity is zero.
       *
       * @function
       * @name CartViewModel#removeItem
       * @param {Object} product Product to remove from cart
       */
      self.removeItem = function(product) {
        if (product === undefined) {
          return;
        }
        // Remove the item from the cart view model
        self.items.remove(product);
        self.allItems.remove(product);
        self.markDirty();
        // To remove item from drop-down mini-cart
        $.Topic(pubsub.topicNames.CART_REMOVE_SUCCESS).publishWith([{message:"success"}]);
      };

      /**
       * Remove all items from the cart.
       *
       * @function
       * @name CartViewModel#emptyCart
       */
      self.emptyCart = function() {
        self.items.removeAll();
        self.allItems.removeAll();
        self.shippingMethod('');
        $.Topic(pubsub.topicNames.CHECKOUT_RESET_SHIPPING_METHOD).publish();
        self.numberOfItems(0);
        self.total(0);
        self.totalWithoutTax(0);
        self.subTotal(0);
        self.amount(0);
        self.shipping(0);
        self.shippingDiscount(0);
        self.shippingSurcharge(0);
        self.tax(0);
        self.currencyCode('');
        self.orderDiscount(0);
        self.giftCards([]);
        self.giftWithPurchaseOrderMarkers = [];
        self.placeHolderItems.removeAll();
        if (self.orderDiscountDescList()) {
          self.orderDiscountDescList.removeAll();
        }
        if (self.coupons() &amp;&amp; self.coupons().length > 0) {
          self.coupons.removeAll();
        }

        if (self.couponMultiPromotions() &amp;&amp; self.couponMultiPromotions().length > 0) {
            self.couponMultiPromotions.removeAll();
            self.claimedCouponMultiPromotions.removeAll();
        }

        if (self.dynamicProperties() &amp;&amp; self.dynamicProperties().length > 0) {
          self.dynamicProperties.removeAll();
        }

        self.cartUpdated();
      };

      /**
       * Function to be invoked on successful order submission.
       *
       * @private
       * @function
       * @name CartViewModel#handleOrderSubmit
       */
      self.handleOrderSubmit = function() {
        self.emptyCart();
        if (self.user().loggedIn() &amp;&amp; (self.user().orderId() &amp;&amp; self.user().orderId()!='')) {
          self.removeCurrentProfileOrder();
        }
      };

      /**
       * Function to be invoked when the shipping method is updated.
       *
       * @private
       * @function
       * @name CartViewModel#updateShippingMethod
       */
      self.updateShippingMethod = function() {
        if (this &amp;&amp; this.repositoryId) {
          log.info("cart.js : updateShippingMethod - entering repositoryId =" + this.repositoryId);
          self.shippingMethod(this.repositoryId);
          self.shipping(this.shippingCost);
          if (self.items().length) {
            self.priceCartForCheckout();
          }
          log.info("cart.js : updateShippingMethod - exiting");
        } else {
          self.shippingMethod('');
          self.shippingDiscount(0);
          self.shippingSurcharge(0);
          // If we had previously priced for checkout then we need to reset pricing.
          if (self.shipping() != 0 ) {
            self.markDirty();
          }
        }
      };

      /**
       * Function to be invoked when the shipping methods loaded.
       *
       * @private
       * @function
       * @name CartViewModel#shipppingMethodsLoaded
       */
      self.shippingMethodsLoaded = function() {
    	var shippingOption, shippingMethodfound = false;
    	if (this.shippingOptions()) {
          for (var i = 0; i &lt; this.shippingOptions().length; i++) {
            if (self.shippingMethod() &amp;&amp; self.shippingMethod() === this.shippingOptions()[i].repositoryId) {
              shippingOption = this.shippingOptions()[i];
              shippingMethodfound = true;
              break;
            }
          }
          if (!shippingMethodfound) {
            //do we need to send invalidshippingMethod notification?
            for (var i = 0; i &lt; this.shippingOptions().length; i++) {
              if(this.defaultShipping() === this.shippingOptions()[i].repositoryId) {
                shippingOption = this.shippingOptions()[i];
                break;
              }
            }
          }
    	}
    	$.Topic(pubsub.topicNames.CHECKOUT_SHIPPING_METHOD).publishWith(
    			shippingOption, [ {
                  message : "success"
                } ]);
      };

      /**
       * Function to be invoked when shipping address is updated.
       *
       * @private
       * @function
       * @name CartViewModel#updateShippingAddress
       */
      self.updateShippingAddress = function () {
        if (this &amp;&amp; this["shippingAddress"].validateForShippingMethod()) {
          var oldShippingAddress = self.shippingAddress();	
          self.shippingAddress(this["shippingAddress"].toJSON());
          
          if(self.isShippingAddressChanged(self.shippingAddress(), oldShippingAddress) || 
        		  (!self.shippingMethod())){
            $.Topic(pubsub.topicNames.RELOAD_SHIPPING_METHODS).publishWith(
              this, [ {
                message : "success"
            } ]);
          }
        } else {
          self.shippingAddress('');
        }
      };

      /**
       * Clear cart shipping address information. Invoked when shipping address is cleared.
       *
       * @function
       * @name CartViewModel#resetShippingAddress
       */
      self.resetShippingAddress = function () {
        self.shippingAddress('');
      };

      /**
       * Update cart item with new quantity.
       *
       * @private
       * @function
       * @name CartViewModel#updateQuantity
       */
      self.updateQuantity = function() {
        self.events.push(new CartEvent(CART_EVENT_UPDATE, 0, this));
        var cookieData = self.getCookieDataAndCompare();
        if(cookieData &amp;&amp; !self.isMatchingCookieData()) {
          self.getLocalData(cookieData);
        } else {
          self.updateItemQuantity(this);
        }
      };

      /**
       * Validate quantity and update cart item if valid.
       *
       * @function
       * @name CartViewModel#updateItemQuantity
       * @param {Object} data Object containing item data to update if it exists in the cart.
       */
      self.updateItemQuantity = function(data) {
        var cartItem = self.getCartItem(data.id, data.childSKUs[0].repositoryId);
        if (cartItem !== null) {
          var product = cartItem;
          if (product.productPriceChanged()) {
            product.productPriceChanged(false);
          }
          if (product.updatableQuantity.isValid()) {
            var numQuantity = parseInt(product.updatableQuantity());
            if (!numQuantity) {
              self.removeItem(product);
            } else {
              product.quantity(parseFloat(product.updatableQuantity()));
              //validate the stock status for the updated quantity and then proceed to pricing
              self.validateProduct(product);
              //update dropdown mini-cart
              $.Topic(pubsub.topicNames.CART_UPDATE_QUANTITY_SUCCESS).publishWith(function() {[{message:"success"}];});
            }
          }
        }
      };

      /**
       * Trigger the getProductsAvailability end point with the updated product quantity and
       * based on the success or error call back validate the product stock status.
       *
       * @private
       * @function
       * @name CartViewModel#validateProduct
       * @param {Object} product Product to validate.
       */
      self.validateProduct = function(product) {
        var catalogId = this.catalogId();
        if(self.user().catalogId) {
          catalogId = self.user().catalogId();
        }
        var id = new Array(product.catRefId, product.productId, catalogId);
        self.adapter.loadJSON('getStockStatus',id ,null ,
          //success callback
          function(data) {
            self.validateProductForPricing(data);
          },
          //error callback
          function(data) {
            self.reloadCart();
          }
        );
      };

      /**
       * Check the stock status of the product and if it's good to go then proceed with pricing. Otherwise,
       * reload the cart.
       *
       * @function
       * @name CartViewModel#validateProductForPricing
       * @param {Object} data Product data to validate.
       */
      self.validateProductForPricing = function (data) {
        if (data.stockStatus === 'IN_STOCK') {
          for (var i = 0; i &lt; self.items().length; i++) {
            if ((self.items()[i].productId === data.productId) &amp;&amp; (self.items()[i].catRefId === data.catRefId)) {
              if (self.items()[i].updatableQuantity() &lt;= data.orderableQuantity) {
                self.items()[i].stockStatus(true);
                self.updatedProduct(self.items()[i].catRefId);
                self.markDirty();
                return;
              } else {
                self.reloadCart();
                return;
              }
            }
          }
          self.reloadCart();
        } else {
          self.reloadCart();
        }
      };

      var viewChangedHandler = function() {
        notifications.emptyGrowlMessages();

        for (var i = 0; i &lt; self.items().length; i++) {
          self.items()[i].revertQuantity();
        }
      };

      /**
       * Return the cart Item based on the productId and catRefId passed.
       *
       * @function
       * @name CartViewModel#getCartItem
       * @param {string} productId Product ID.
       * @param {string} catRefId Catalog reference ID.
       * @returns {CartItem} Cart item if it exists, otherwise null.
       */
      self.getCartItem = function (productId, catRefId) {
        for (var i = 0; i &lt; self.items().length; i++) {
          if ((self.items()[i].productId === productId) &amp;&amp; (self.items()[i].catRefId === catRefId)) {
            return self.items()[i];
          }
        }
        return null;
      };

      /**
       * Return a localized text for remove coupon link for accessibility.
       *
       * @function
       * @name CartViewModel#getRemoveCouponReadText
       * @returns {string} Localized text for remove coupon link.
       */
      self.getRemoveCouponReadText = function() {
        return CCi18n.t('ns.common:resources.removeCouponLinkReadText');
      };

      /**
       * This method populates the gift cards to the pricing model
       */
      self.populateGiftCards = function(pricingModel, lastCartEvent) {
        if (self.giftCards().length > 0) {
          pricingModel.payments = [];
          for ( var i = 0; i &lt; self.giftCards().length; i++) {
            var giftItem = {};
            var giftCard = self.giftCards()[i];
            giftItem['type'] = ccConstants.GIFT_CARD_PAYMENT_TYPE;
            giftItem['giftCardNumber'] = giftCard.giftCardNumber();
            giftItem['giftCardPin'] = giftCard.giftCardPin();
            if (giftCard.amountInGiftCard() ) {
              if(!(lastCartEvent &amp;&amp; lastCartEvent.type === CART_EVENT_GIFTCARD_REAPPLY &amp;&amp;
            		  lastCartEvent.product.giftCardNumber() === giftCard.giftCardNumber() )){
            	  giftItem['amount'] = giftCard.amountInGiftCard();
              }
            }
            pricingModel.payments.push(giftItem);
          }
        }
      };

      /**
       * this validates the gift cards data on the place order
       */
      self.validateGiftCards = function() {
        for ( var i = 0; i &lt; self.giftCards().length; i++) {
          var giftItem = self.giftCards()[i];
         if (!giftItem.validateNow()) {
            return false
          }
        }
        return true;
      };

      /**
       * this updates the allItems array after cart is ready/updated.
       */
      self.updateAllItemsArray = function() {
        self.allItems.removeAll();
        ko.utils.arrayForEach(self.items(), function(item) {
          self.allItems.push(item);
        });
        ko.utils.arrayForEach(self.placeHolderItems(), function(item) {
          self.allItems.push(item);
        });
      };


      // Subscribe to add to cart
      $.Topic(pubsub.topicNames.CART_ADD).subscribe(self.addToCart);
      $.Topic(pubsub.topicNames.CART_REMOVE).subscribe(self.removeFromCart);
      $.Topic(pubsub.topicNames.ORDER_SUBMISSION_SUCCESS).subscribe(self.handleOrderSubmit);
      $.Topic(pubsub.topicNames.CART_UPDATE_QUANTITY).subscribe(self.updateQuantity);
      $.Topic(pubsub.topicNames.CHECKOUT_SHIPPING_METHOD).subscribe(self.updateShippingMethod);
      $.Topic(pubsub.topicNames.PAGE_CONTEXT_CHANGED).subscribe(notifications.emptyGrowlMessages);
      $.Topic(pubsub.topicNames.PAGE_VIEW_CHANGED).subscribe(viewChangedHandler);
      $.Topic(pubsub.topicNames.PAGE_LAYOUT_UPDATED).subscribe(self.initCatalog.bind(self));
      $.Topic(pubsub.topicNames.LOAD_CHECKOUT).subscribe(self.checkPriceDataAndRedirect);
      $.Topic(pubsub.topicNames.POPULATE_SHIPPING_METHODS).subscribe(self.updateShippingAddress);
      $.Topic(pubsub.topicNames.CHECKOUT_SHIPPING_ADDRESS_INVALID).subscribe(self.resetShippingAddress);
      $.Topic(pubsub.topicNames.USER_PROFILE_ADDRESSES_REMOVED).subscribe(self.resetShippingAddress);
      $.Topic(pubsub.topicNames.USER_AUTO_LOGIN_SUCCESSFUL).subscribe(self.loadCartForProfile.bind(self));
      $.Topic(pubsub.topicNames.USER_LOAD_CART).subscribe(self.loadCartForProfile.bind(self));
      $.Topic(pubsub.topicNames.USER_CLEAR_CART).subscribe(self.clearCartForProfile.bind(self));
      $.Topic(pubsub.topicNames.REFRESH_USER_CART).subscribe(self.refreshUserCart.bind(self));
      $.Topic(pubsub.topicNames.REMOVE_INVALID_ITEMS).subscribe(self.handleInvalidItems.bind(self));
      $.Topic(pubsub.topicNames.ORDER_SUBMISSION_FAIL).subscribe(self.clearPins.bind(self));
      $.Topic(pubsub.topicNames.PAGE_CHANGED).subscribe(self.clearPins.bind(self));
      $.Topic(pubsub.topicNames.USER_LOGOUT_SUBMIT).subscribe(self.clearPins.bind(self));
      $.Topic(pubsub.topicNames.USER_SESSION_RESET).subscribe(self.clearPins.bind(self));
      $.Topic(pubsub.topicNames.GIFTCARD_REAPPLY_PINS).subscribe(self.reApplyGiftCardPins.bind(self));
      $.Topic(pubsub.topicNames.PLACE_HOLDER_REMOVE).subscribe(function(item) {
        self.removePlaceHolderFromCart(item);
      });

      // When user logs out or session expires, reset the shipping address
      $.Topic(pubsub.topicNames.USER_LOAD_SHIPPING).subscribe(function(obj) {
        if (self.user() &amp;&amp; !self.user().loggedIn()) {
          self.resetShippingAddress();
        }
      });

      return(self);
    }

    /**
     * Callback to load server side cart info on receiving a USER_LOGIN_SUCCESSFUL or
     * USER_AUTO_LOGIN_SUCCESSFUL pubsub event.
     *
     * @private
     * @function
     * @name CartViewModel#loadCartForProfile
     */
    CartViewModel.prototype.loadCartForProfile = function(user) {
      var self = this;
      notifier.clearError(CART_VIEW_MODEL_ID);
      var clearCoupons = true;
      if (self.user() &amp;&amp; !self.user().loggedinAtCheckout()) {
        if(user &amp;&amp; user.catalog) {
          var catalogId = user.catalog.repositoryId;
          if(this.catalogId() != catalogId){
            this.catalogId(catalogId);
          }
        }
        self.adapter.loadJSON('getCurrentProfileOrder', '0', null,
          //success callback
          function(data) {
            if (data &amp;&amp; data.orderId) {
              self.user().orderId(data.orderId);
              self.user().persistedOrder(data);
              self.user().setLocalData('orderId');
              var itemsRemoved = self.removeItems(data);
              self.mergeItems(data);
              self.isPricingRequired(true);
              self.validateServerCart();
              self.getProductData();
              self.getDynamicPropertiesMetadata(true);
              self.updateDynamicProperties(data);
            } else if (self.items() &amp;&amp; self.items().length > 0){
              self.validateServerCart();
              self.createCurrentProfileOrder();
            }
          },
          //error callback
          function(data) {
            self.loadCart();
          }
        );
      }
    };

    /**
     * Checks if Shipping is required.
     *
     * @function
     * @name CartViewModel#isShippingAddressChanged
     */
    CartViewModel.prototype.isShippingAddressChanged = function (newAddress, oldAddress) {
      return  ( newAddress.state &amp;&amp;  newAddress.state != oldAddress.state) ||
          ( newAddress.postalCode &amp;&amp; newAddress.postalCode != oldAddress.postalCode) ||
          ( newAddress.country &amp;&amp; newAddress.country != oldAddress.country );
    };

    /**
     * Remove invalid items from the shopping cart in the given data object. This method
     * will mutate the data object passed as a parameter.
     *
     * @function
     * @name CartViewModel#removeItems
     * @param {Object} data Data to be processed
     * @param {CartItem[]} data.shoppingCart.items Array of cart items to check validity and remove.
     * @returns boolean true if any cart items were removed, otherwise false.
     */
    CartViewModel.prototype.removeItems = function (data) {
      var self = this;
      var itemsRemoved = false;
      var items = data.shoppingCart.items;
      for (var i=0; i &lt; items.length; i++) {
        if (!items[i].isItemValid) {
          if (items[i].displayName &amp;&amp; self.invalidProductNames.indexOf(items[i].displayName) == -1) {
            self.invalidProductNames.push(items[i].displayName);
          }
          items.splice(i, 1);
          i--;
          itemsRemoved = true;
        }
      }
      return itemsRemoved;
    };

    /**
     * Compare items in the cart with items in the cookie data.
     *
     * @function
     * @CartViewModel#compareItems
     * @param {Object[]} cookieItems List of cart items from cookie to compare with current cart items.
     * @returns {boolean} true if both collections contain the same items, otherwise false, probably.
     */
    CartViewModel.prototype.compareItems = function (cookieItems) {
      var self = this;
      var items = cookieItems;
      var productFound;
      if(items.length != self.items().length || items.length == 0) {
        return false;
      } else if(items.length == 0) {
        return true;
      }
      var lastCartEvent = self.events.pop();
      if (lastCartEvent) {
        self.events.push(lastCartEvent);
      }
      for (var j = 0; j &lt; self.items().length; j++) {
        productFound = false;
        for (var i=0; i &lt; items.length; i++) {
          if (items[i].productId == self.items()[j].productId &amp;&amp; items[i].catRefId == self.items()[j].catRefId) {
            if(!(lastCartEvent &amp;&amp; lastCartEvent.type == 2 &amp;&amp; lastCartEvent.product.id == items[i].productId)) {
            	if(items[i].quantity != self.items()[j].quantity()) {
            		self.items()[j].quantity(items[i].quantity);
            		self.items()[j].updatableQuantity(items[i].quantity);
            	}
            }
            productFound = true;
            break;
          }
        }
        if(!productFound) {
           return false;
        }
      }
      return true;
    };

    CartViewModel.prototype.compareItemsAndQuantity = function (cookieItems) {
        var self = this;
        var items = cookieItems;
        var productFound;
        if(items.length != self.items().length || items.length == 0) {
          return false;
        } else if(items.length == 0) {
          return true;
        }
        var lastCartEvent = self.events.pop();
        if (lastCartEvent) {
          self.events.push(lastCartEvent);
        }
        for (var j = 0; j &lt; self.items().length; j++) {
          productFound = false;
          for (var i=0; i &lt; items.length; i++) {
            if (items[i].productId == self.items()[j].productId &amp;&amp; items[i].catRefId == self.items()[j].catRefId) {
              if(!(lastCartEvent &amp;&amp; lastCartEvent.type == 2 &amp;&amp; lastCartEvent.product.id == items[i].productId)) {
              	if(items[i].quantity != self.items()[j].quantity() ) {
              		break;
              	}
              }
              productFound = true;
              break;
            }
          }
          if(!productFound) {
             return false;
          }
        }
        return true;
      };
    
    
    /**
     * Compare coupons in the parameter with coupons in the cart.
     *
     * @function
     * @name CartViewModel#compareCoupons
     * @param {Object[]} coupons List of coupons to compared against coupons on the cart.
     * @returns {boolean} true if the lists contain the same coupons, otherwise false.
     */
    CartViewModel.prototype.compareCoupons = function (coupons) {
      var self = this;
      var couponFound;
      if(coupons.length != self.coupons().length) {
          return false;
      } else if(coupons.length == 0) {
        return true;
      }
      for (var j = 0; j &lt; self.coupons().length; j++) {
        couponFound = false;
        for (var i=0; i &lt; coupons.length; i++) {
          if (coupons[i].code == self.coupons()[j].code()) {
            couponFound = true;
          }
        }
        if(!couponFound) {
           return false;
        }
      }
      return true;
    };

    /**
     * Merge the items from the parameter into the list of items in cart. If a product already exists in the
     * cart then update the quantity.
     *
     * @function
     * @name CartViewModel#mergeItems
     * @param {Object} data Data object
     * @param {CartItem} data.shoppingCart.items List of cart items in the data parameter to merge into the cart.
     */
    CartViewModel.prototype.mergeItems = function (data) {
      var self = this;
      var items = data.shoppingCart.items;
      var addItems = [];
      for (var i=0; i &lt; items.length; i++) {
        var found = false;
        for (var j = 0; j &lt; self.items().length; j++) {
          if (items[i].productId == self.items()[j].productId &amp;&amp; items[i].catRefId == self.items()[j].catRefId) {
            var updatedQuantity = items[i].quantity + self.items()[j].quantity();
            self.items()[j].quantity(updatedQuantity);
            self.items()[j].updatableQuantity(updatedQuantity);
            self.items()[j].discountInfo(items[i].discountInfo);
            self.items()[j].rawTotalPrice(items[i].rawTotalPrice);
            self.items()[j].detailedItemPriceInfo(items[i].detailedItemPriceInfo);
            found = true;
            break;
          }
        }
        if (!found) {
          addItems.push(items[i]);
        }
      }
      for (var i=0; i&lt;addItems.length; i++) {
        var selectedOptions = getSelectedOptions(addItems[i]);
        var item = new CartItem(
            addItems[i].productId, null, addItems[i].quantity, 
            addItems[i].catRefId, selectedOptions, self.currency, 
            addItems[i].discountInfo, addItems[i].rawTotalPrice, 
            addItems[i].externalPrice, addItems[i].externalPriceQuantity);
        item.itemTotal(addItems[i].price);
        item.originalPrice(addItems[i].unitPrice);
        item.updatableQuantity(addItems[i].quantity);
        item.detailedItemPriceInfo(addItems[i].detailedItemPriceInfo);
        if(data.priceListGroup &amp;&amp; data.priceListGroup.repositoryId != null) {
          item.priceListGroupId(data.priceListGroup.repositoryId);
        }
        self.items.push(item);
      }
    };

    /**
     * Create  a javascript object representing the selection items for an items variants.
     *
     * @private
     * @function
     */
    function getSelectedOptions(item) {
      var selectedOptions = null;
      if (item.variant &amp;&amp; item.variant.length > 0) {
        var options = item.variant;
        selectedOptions = [];
        for (var j = 0; j &lt; options.length; j++) {
          selectedOptions.push({'optionName': options[j].optionName, 'optionValue': options[j].optionValue});
        }
      }
      return selectedOptions;
    };

    /**
     * Validate the cart after merge, but before redirecting to checkout.
     *
     * @function
     * @name CartViewModel#validateServerCart
     */
    CartViewModel.prototype.validateServerCart = function() {
      var self = this;
      if (self.user().pageToRedirect() &amp;&amp; self.user().pageToRedirect() == self.checkoutLink) {
        self.validateAndRedirectCart(true);
      } else {
        self.validateAndRedirectCart(false);
      }
    };

    /**
     * Clear client cart after logout, or when not logged in. Invoked on receiving a USER_CLEAR_CART
     * pubsub event.
     *
     * @private
     * @function
     * @CartViewModel#clearCartForProfile
     * @param {Object} userData User object to be used if self.user() is unset.
     */
    CartViewModel.prototype.clearCartForProfile = function(userData) {
      var self = this;
      if (!self.user()) {
        self.user(userData);
      }
      if (self.user()) {
        self.user().persistedOrder(null);
        if (!self.user().loggedinAtCheckout() &amp;&amp; !self.user().loggedoutAtCheckout() &amp;&amp; self.user().orderId() != '') {
          self.emptyCart();
        }
        self.user().orderId('');
        self.user().setLocalData('orderId');
      }
    };

    /**
     * Refresh the cart data from the server.
     *
     * @private
     * @function
     * @name CartViewModel#refreshUserCart
     * @param {Object} userData User object to be used if self.user() is unset.
     */
    CartViewModel.prototype.refreshUserCart = function(userData) {
      var self = this;
      if (!self.user()) {
        self.user(userData);
      }
      if (!self.updatedFromRepository) {
        if (self.user() &amp;&amp; self.user().loggedIn() &amp;&amp; !self.user().loggedinAtCheckout() &amp;&amp; !navigation.isPathEqualTo(self.checkoutLink)) {
          self.adapter.loadJSON('getCurrentProfileOrder', '0', null,
              //success callback
              function(data) {
                if (data!=null &amp;&amp; data.orderId) {
                  self.user().orderId(data.orderId);
                  self.user().persistedOrder(data);
                  self.user().setLocalData('orderId');
                  var itemsRemoved = self.removeItems(data);
                  self.isPricingRequired(itemsRemoved);
                  if (!self.compareItemsAndQuantity(data.shoppingCart.items)) {
                	  self.updateCartData(data, true);
                	  self.isPricingRequired(true);
                  }
                  self.getProductData();
                  self.getDynamicPropertiesMetadata(true)
                  self.updateDynamicProperties(data);
                  self.cartUpdated();
                } else {
                  self.emptyCart();
                  self.user().orderId('');
                  self.user().persistedOrder(null);
                  self.user().setLocalData('orderId');
                }
              },
              //error callback
              function(data) {
                self.loadCart();
              }
            );
        }
      }
    };


    //handle the errors with invalid items with deleted products and skus while updating the server side cart
    /**
     * Handle invalid items and deleted products/SKUs while updating server-side cart.
     *
     * @private
     * @function
     * @name CartViewModel#handleInvalidItems
     * @param {Object} data
     */
    CartViewModel.prototype.handleInvalidItems = function(data) {
      var self = this;
      if (data.errorCode == ccConstants.CREATE_ORDER_PRODUCT_NOT_FOUND) {
        var itemsRemovedFromCart = self.removeItemsByProduct(data.moreInfo);
        self.markDirty();
      }
      if (data.errorCode == ccConstants.CREATE_ORDER_SKU_NOT_FOUND) {
        var moreInfo = JSON.parse(data.moreInfo);
        var itemsRemovedFromCart = self.removeItemsByProductCatRef(moreInfo.productId, moreInfo.catRefId);
        self.markDirty();
      }
    };

    /**
     * Initialize/reload Catalog data when page is changed or loaded.
     *
     * @private
     * @function
     * @name CartViewModel#initCalalog
     */
    CartViewModel.prototype.initCatalog = function() {
      var self = this;
      if (arguments[0].data.global.user &amp;&amp; arguments[0].data.global.user.catalog) {
        var catalogId = arguments[0].data.global.user.catalog.repositoryId;

        if (this.catalogId() != catalogId) {
          this.catalogId(catalogId);
        }
      }
      //this is added as part of initCatalog to load the cart each time cart page loaded.
      if(!navigation.isPathEqualTo(self.checkoutLink))
    	  this.loadCart();
    };

    /**
     * Load cart data from the shopping cart local storage.
     *
     * @function
     * @name CartViewModel#loadCart
     */
    CartViewModel.prototype.loadCart = function() {
      var self = this;

      self.isDirty(false);

      if (!self.updatedFromRepository) {
        //if the user is logged in and has a server side cart, then load the cart from the server instead of cookie, except on checkout page
        if (navigation.isPathEqualTo(self.checkoutLink) || (! (self.user() &amp;&amp; self.user().loggedIn() &amp;&amp; !self.user().loggedinAtCheckout() &amp;&amp; self.user().orderId()))) {
          // Read product ID's and quantities from local storage if there are any
          var cookieData = self.getCookieData();
          if (cookieData != null) {
           self.getLocalData(cookieData);
          }
        }
      }
    };

    /**
     * Loads cart data from the shopping cart from the server in case of server side cart,
     * or from the cookie in the case of an anonymous user
     *
     * @function
     * @name CartViewModel#reloadCart
     */
    CartViewModel.prototype.reloadCart = function() {
      var self = this;
      if (self.user() &amp;&amp; self.user().loggedIn() &amp;&amp; !self.user().loggedinAtCheckout()) {
        self.isDirty(false);
        self.refreshUserCart(self.user());
      } else {
        self.loadCart();
      }
    };

    /**
     * Return the price of the cart item.
     * If product in the item has variants, then price for the sku to be considered, if it not null
     * otherwise product price will be considered.
     *
     * @function
     * @name CartViewModel#getItemPrice
     * @param {CartItem} item Item to get the price
     * @returns {number} Calculated price of item taking into account child SKUs and salePrice.
     */
    CartViewModel.prototype.getItemPrice = function (item) {
        var itemPrice = 0;
        if (item.productData() != null) {
          if (item.productData().childSKUs) {
            //the product has variant
            var childSkus = item.productData().childSKUs;
            var childSkusCount = item.productData().childSKUs.length;
            for (var i = 0; i &lt; childSkusCount; i++) {
              if (item.productData().childSKUs[i].repositoryId == item.catRefId) {
                var matchingSku = item.productData().childSKUs[i];
                if (matchingSku.salePrice != null) {
                  itemPrice = matchingSku.salePrice;
                } else if (item.productData().salePrice != null) {
                  itemPrice = item.productData().salePrice;
                } else if (matchingSku.listPrice != null) {
                  itemPrice = matchingSku.listPrice;
                } else {
                  itemPrice = item.productData().listPrice;
                }
              }
            }
          } else if (item.productData().salePrice != null) {
            itemPrice = item.productData().salePrice;
          } else {
            itemPrice = item.productData().listPrice;
          }
          return itemPrice;
        }
      };

    /**
     * Saves the current cart information into the shopping cart local storage.
     *
     * @private
     * @function
     * @name CartViewModel#saveCartCookie
     */
    CartViewModel.prototype.saveCartCookie = function () {
      var self = this;
      var isPriceOverridden = false;
      // Write the view model details to local storage
      var shoppingCartCookie = new Object();
      shoppingCartCookie.numberOfItems = self.numberOfItems();
      shoppingCartCookie.total = self.total();
      shoppingCartCookie.totalWithoutTax = self.totalWithoutTax();
      shoppingCartCookie.subTotal = self.subTotal();
      shoppingCartCookie.amount = self.amount();
      shoppingCartCookie.tax = self.tax();
      shoppingCartCookie.currencyCode = self.currencyCode();
      shoppingCartCookie.shipping = self.shipping();
      shoppingCartCookie.shippingDiscount = self.shippingDiscount();
      shoppingCartCookie.shippingSurcharge = self.shippingSurcharge();
      shoppingCartCookie.orderDiscount = self.orderDiscount();
      shoppingCartCookie.orderDiscountDescList = self.orderDiscountDescList();
      shoppingCartCookie.coupons = self.coupons();
      shoppingCartCookie.cartPriceListGroupId = SiteViewModel.getInstance().selectedPriceListGroup().id;
      shoppingCartCookie.giftWithPurchaseOrderMarkers = self.giftWithPurchaseOrderMarkers;

      shoppingCartCookie.items = new Array();

      //local storage data to be compared with price change
      var cookieData = self.getCookieData();

      // If the local storage data comes back as a string, convert it to JSON - only happens in phantomjs.
      if (typeof cookieData === 'string') {
        cookieData = JSON.parse(cookieData);
      }

      var productData = {};
      if (cookieData != null) {
        for (var i = 0; i &lt; cookieData.items.length; i++) {
          if (productData[cookieData.items[i].catRefId] === undefined) {
            productData[cookieData.items[i].catRefId] = cookieData.items[i].originalPrice;
          }
        }
      }

      var persistedOrder = self.user().persistedOrder();
      if (persistedOrder &amp;&amp; persistedOrder.shoppingCart.items) {
        var persistedCart = persistedOrder.shoppingCart;
        var itemsCount = persistedCart.items.length;
        for (var i = 0; i &lt; itemsCount; i++) {
          if (productData[persistedCart.items[i].catRefId] === undefined) {
            productData[persistedCart.items[i].catRefId] = persistedCart.items[i].unitPrice;
          }
        }
      }

      for (var i = 0; i &lt; self.items().length; i++) {
        var originalPrice = 0;
        var itemPrice = self.getItemPrice(self.items()[i]);
        //to check if the product is not added to local storage
        if (productData[self.items()[i].catRefId] == undefined) {
            originalPrice = itemPrice;
        } else {
          //if the product is updated then updated the list price or sale price
          if (self.updatedProduct() != '' &amp;&amp; self.updatedProduct() === self.items()[i].catRefId) {
            originalPrice = itemPrice;
            self.updatedProduct('');
          } else {
            originalPrice = productData[self.items()[i].catRefId];
          }
        }
        // If currency changes, the original price should be overridden
        if ((self.items()[i].priceListGroupId() != SiteViewModel.getInstance().selectedPriceListGroup().id) &amp;&amp;
          (itemPrice != undefined)) {
          self.items()[i].priceListGroupId(SiteViewModel.getInstance().selectedPriceListGroup().id);
          originalPrice = itemPrice;
          isPriceOverridden = true;
        }
        self.items()[i].originalPrice(originalPrice);

        shoppingCartCookie.items.push({
          productId: self.items()[i].productId,
          quantity: self.items()[i].quantity(),
          catRefId: self.items()[i].catRefId,
          itemTotal: self.items()[i].itemTotal(),
          originalPrice: originalPrice,
          selectedOptions: self.items()[i].selectedOptions,
          discountInfo: self.items()[i].discountInfo(),
          detailedItemPriceInfo: self.items()[i].detailedItemPriceInfo(),
          externalPrice: self.items()[i].externalPrice(),
          externalPriceQuantity: self.items()[i].externalPriceQuantity(),
          isGWPChoicesAvaliable: self.items()[i].isGWPChoicesAvaliable(),
          giftData: (self.items()[i].giftData ? self.items()[i].giftData : null),
          giftWithPurchaseCommerceItemMarkers: self.items()[i].giftWithPurchaseCommerceItemMarkers
        });
      }
      
      if (isPriceOverridden) {
        self.cartPriceListGroupId(SiteViewModel.getInstance().selectedPriceListGroup().id);
      }
      // Add dynamic properties
      if (self.dynamicProperties) {
        // Ensure we have dynamic property metadata
        // to aid setting of default values
        self.getDynamicPropertiesMetadata(true);

        // Add the current dynamic property values
        shoppingCartCookie.dynamicProperties = new Array();
        for (var i = 0; i &lt; self.dynamicProperties().length; i++) {
          var dynPropItem = self.dynamicProperties()[i];
          var dynPropId = dynPropItem.id();
          var dynPropValue = null;
          if (dynPropItem.value() != null) {
            dynPropValue = dynPropItem.value();
          }
          shoppingCartCookie.dynamicProperties.push({
            id: dynPropId,
            value: dynPropValue
          });
        }
      }

      // Write the shopping cart to local storage
      try {
        storageApi.getInstance().setItem("shoppingCart", JSON.stringify(shoppingCartCookie));
      }
      catch(pError) {
      }
    };

    /**
     * Reads the shopping cart from local storage and populates the Cart object with data of cookie.
     *
     * @private
     * @function
     * @param {Object} cookieData the local storage data containing the shopping cart information
     *
     */
    CartViewModel.prototype.getLocalData = function(cookieData) {
      var self = this;
      
      // If the local storage data is not JSON, convert it - especially for phantomjs.
      if (typeof cookieData === 'string') {
        cookieData = JSON.parse(cookieData);
      }

      if(cookieData) {
        // Add product ID's and quantities from local storage to the widget context
        self.numberOfItems(cookieData.numberOfItems);
        self.total(cookieData.total);
        self.totalWithoutTax(cookieData.totalWithoutTax);
        self.subTotal(cookieData.subTotal);
        self.amount(cookieData.amount);
        self.tax(cookieData.tax);
        self.currencyCode(cookieData.currencyCode);
        self.shipping(cookieData.shipping);
        self.shippingDiscount(cookieData.shippingDiscount);
        self.shippingSurcharge(cookieData.shippingSurcharge);
        self.orderDiscount(cookieData.orderDiscount);
        self.orderDiscountDescList(cookieData.orderDiscountDescList);
        self.cartPriceListGroupId(cookieData.cartPriceListGroupId);
        self.giftWithPurchaseOrderMarkers = cookieData.giftWithPurchaseOrderMarkers;


        // As coupon code and description are observables,
        //  access the local data and set them.
        self.coupons.splice(0);
        if (cookieData.hasOwnProperty('coupons')) {
          for (var i = 0; i &lt; cookieData.coupons.length; i++) {
            var couponItem = new Coupon(cookieData.coupons[i].code, cookieData.coupons[i].description, cookieData.coupons[i].status, cookieData.coupons[i].level, cookieData.coupons[i].id, cookieData.coupons[i].totalAdjustment);
            self.coupons.push(couponItem);
          }
        }

        self.populateClaimedCouponMultiPromotions(self.couponMultiPromotions());

        self.items.splice(0);
        for (var i = 0; i &lt; cookieData.items.length; i++) {
          var productItem = new CartItem(cookieData.items[i].productId,
            undefined, cookieData.items[i].quantity, 
            cookieData.items[i].catRefId, cookieData.items[i].selectedOptions, 
            self.currency, cookieData.items[i].discountInfo, 
            cookieData.items[i].rawTotalPrice, 
            cookieData.items[i].externalPrice,
            cookieData.items[i].externalPriceQuantity);
          productItem.itemTotal(cookieData.items[i].itemTotal);
          productItem.originalPrice(cookieData.items[i].originalPrice);
          productItem.productPriceChanged(false);
          productItem.detailedItemPriceInfo(cookieData.items[i].detailedItemPriceInfo);
          productItem.priceListGroupId(cookieData.cartPriceListGroupId);
          productItem.isGWPChoicesAvaliable(cookieData.items[i].isGWPChoicesAvaliable);
          if (cookieData.items[i].giftWithPurchaseCommerceItemMarkers) {
            productItem.giftWithPurchaseCommerceItemMarkers = cookieData.items[i].giftWithPurchaseCommerceItemMarkers;
          }
          if (cookieData.items[i].giftData) {
            productItem.giftData = cookieData.items[i].giftData;
          }
          self.items.push(productItem);
        }
      }
      if (self.items().length > 0) {
        //make a REST call to update the stock status and orderable quantity
        self.getProductData();
      }
      
      // Fetch metadata on custom order properties
      self.getDynamicPropertiesMetadata(true);
      
      // Retrieve dynamic property values
      if (cookieData.hasOwnProperty('dynamicProperties')) {
        self.updateDynamicProperties(cookieData);
      }
      
    };

    /**
     * Update item data of each item in the shopping cart with updated information from the server. Keep track
     * of whether any prices have changed.
     *
     * @private
     * @function
     * @name CartViewModel#processCartData
     * @param {Object[]} data List of product objects returned from server.
     * @returns {boolean} true if any product prices have changed, otherwise false.
     */
    CartViewModel.prototype.processCartData = function (data) {
      var self = this;
      var productPriceChanged = false;
      for (var i = 0; i &lt; data.length; i++) {
        var currentProduct = data[i];
        for (var j = 0; j &lt; self.items().length; j++) {
          if (currentProduct.id == self.items()[j].productId) {
            for (var index = 0; index &lt; currentProduct.childSKUs.length; index++) {
              if (currentProduct.childSKUs[index].repositoryId == self.items()[j].catRefId) {
                var skuItem = currentProduct.childSKUs[index];
                var productData = jQuery.extend(true, {}, currentProduct);
                productData.childSKUs = [skuItem];
                self.items()[j].productData(productData);
                //If gift item is present then no need to update the prices, just let productData to be updated
                if (!checkForGiftItem(self.items()[j].discountInfo())) {
                  var itemPrice = self.getItemPrice(self.items()[j]);
                  // *** Suppress price change detection for Products/SKUs with volume prices (bulk/tiered).
                  // *** Temporary fix until CCCO-492 can be resolved.
                  skuItem = skuItem || {};
                  if (skuItem.saleVolumePrice || skuItem.listVolumePrice || productData.saleVolumePrice || productData.listVolumePrice) {
                    self.items()[j].productPriceChanged(false);
                  }
                  else if ((self.items()[j].originalPrice() != itemPrice) &amp;&amp;
                      (SiteViewModel.getInstance().selectedPriceListGroup().id == self.cartPriceListGroupId())) {
                    if (!(self.skipPriceChange() &amp;&amp; self.items()[j].productPriceChanged() &amp;&amp; (self.items()[j].currentPrice() == itemPrice)) &amp;&amp; !self.items()[j].invalid) {
                      productPriceChanged = true;
                    }
                    self.items()[j].productPriceChanged(true);
                  } else {
                    self.items()[j].productPriceChanged(false);
                    //if the price is reset to the original price, we do not need to show the price change notification
                    //but still need to re-price with the latest price
                    if (self.items()[j].currentPrice() &amp;&amp; itemPrice &amp;&amp; self.items()[j].currentPrice() != itemPrice &amp;&amp; !self.items()[j].invalid) {
                      self.isPricingRequired(true);
                    }
                  }
                  if (currentProduct.productVariantOptions) {
                    for (var k = 0; k &lt; currentProduct.productVariantOptions.length; k++) {
                      self.updateItemOptionDetails(currentProduct.productVariantOptions[k], self.items()[j].catRefId);
                    }
                  }
                  break;
                }
              }
            }
          }
        }
      }
      self.skipPriceChange(false);
      self.showSelectedOptions(true);
      return productPriceChanged;
    };

    /**
     * Call the listProducts endpoint to fetch the product data and
     * remove the invalid items from the cart based on the response.
     *
     * @private
     * @function
     * @name CartViewModel#getProductData
     */
    CartViewModel.prototype.getProductData = function () {
      var self = this;
      var productIds = [];
      for (var i = 0; i &lt; self.items().length; i++) {
        if (productIds.indexOf(self.items()[i].productId) === -1) {
          productIds.push(self.items()[i].productId);
        }
      }
      // Make REST calls to get details of all the products in the cart
      var id = new Array(self.catalogId(), productIds, true, SiteViewModel.getInstance().selectedPriceListGroup().id,self.fields);
      var productPriceChanged = false;
      self.adapter.loadJSON('cart', id, null,
        //success callback
        function(data) {
          var itemsRemovedFromCart = self.removeInvalidItems(data, self.invalidProductNames);
          var productPriceChanged = self.processCartData(data);

          //If product price has changed then make a price engine call
          if (itemsRemovedFromCart == true || productPriceChanged === true || self.isPricingRequired() ) {
             //Pushing reprice cart event
             self.events.push(new CartEvent(CART_EVENT_REPRICE, 0, data));
            //if shipping method is set and user is on checkout page then price order total insead of subtotal.
            if (navigation.isPathEqualTo(self.checkoutLink) &amp;&amp; self.shippingMethod() != "") {
              self.priceCartForCheckout();
            } else {
              self.markDirty();
            }
            self.isPricingRequired(false);
          } else if (self.cartPriceListGroupId() &amp;&amp;
                self.cartPriceListGroupId() != SiteViewModel.getInstance().selectedPriceListGroup().id) {
            // As price list group is changed, re-pricing is required.Pushing reprice cart event
            self.events.push(new CartEvent(CART_EVENT_REPRICE, 0, data));
            self.markDirty();
          } else {
             //Publishing price complete when pricing is finished
             $.Topic(pubsub.topicNames.CART_PRICE_COMPLETE).publish();
          }
          self.getCartAvailability();
          self.notifyInvalidProducts();
          // Callback to tell others the cart is ready
          $.Topic(pubsub.topicNames.CART_READY).publish(self);
          self.updateAllItemsArray();
        },
        //error callback
        function(data) {
          if (data.errors &amp;&amp; data.errors.length >0) {
            self.handleListProductsFailure(data);
            self.getProductData();
          }
        });
    };

    /**
     * Create a notification message for any items that have been removed from the cart because they
     * are now invalid.
     *
     * @private
     * @function
     * @param {string} The page where the notitifcation message should be displayed
     * @name CartViewModel#natifyInvalidProducts
     */
    CartViewModel.prototype.notifyInvalidProducts = function (page) {
      var self = this;
      var notificationMsg = "";
      if (self.invalidProductNames.length > 0) {
        var productNames = "";
        var count = self.invalidProductNames.length-1;
        for (var i=0; i &lt; count; i++) {
          productNames = productNames + CCi18n.t('ns.common:resources.productNameHasNext', {productName: self.invalidProductNames[i]});
        }
        productNames = productNames + self.invalidProductNames[count];
        notificationMsg = CCi18n.t('ns.common:resources.invalidCartItemsError', {productNames: productNames});
      }
      if (notificationMsg) {
        if (!page) {
          notifier.sendWarning(CART_VIEW_MODEL_ID, notificationMsg, true);
        } else {
          notifier.sendWarningToPage(CART_VIEW_MODEL_ID, notificationMsg, true, page, true);
        }
      }
      self.invalidProductNames = [];
    };

    /**
     * Remove items from the cart matching the given product ID.
     *
     * @function
     * @name CartViewModel#removeItemsByProduct
     * @param {string} productId Product ID which will be removed from cart.
     * @returns {boolean} true if any items were removed from the cart, otherwise false.
     */
    CartViewModel.prototype.removeItemsByProduct = function (productId) {
      var self = this;
      var itemsRemovedFromCart = false;
      for (var i = 0; i &lt; self.items().length; i++) {
        if (self.items()[i].productId === productId) {
          self.items.remove(self.items()[i]);
          i--;
          itemsRemovedFromCart = true;
          self.isPricingRequired(true);
        }
      }
      return itemsRemovedFromCart;
    };

    /**
     * Remove items from the cart matching both the product ID and catRef (SKU) ID.
     *
     * @function
     * @name CartViewModel#removeItemsByProductCatRef
     * @param {string} productId Product ID which will be removed from cart.
     * @param {string} catRefId Catalog reference (SKU) ID to be removed from cart.
     * @returns {boolean} true if any items were removed from the cart, otherwise false.
     */
    CartViewModel.prototype.removeItemsByProductCatRef = function (productId, catRefId) {
      var self = this;
      var itemsRemovedFromCart = false;
      for (var i = 0; i &lt; self.items().length; i++) {
        if ((self.items()[i].productId === productId) &amp;&amp; (self.items()[i].catRefId === catRefId)) {
          self.items.remove(self.items()[i]);
          i--;
          itemsRemovedFromCart = true;
          self.isPricingRequired(true);
        }
      }
      return itemsRemovedFromCart;
    };

    /**
     * Marks items in the cart as invalid.
     *
     * @function
     * @name CartViewMOdel#markInvalidItems
     * @param {Object[]} data List of items to keep if they are present in the cart.
     * @param {string[]} invalidProductNames  List of names which will be removed from the cart.
     * @returns {boolean} true if any items were removed from the cart, otherwise false.
     */
    CartViewModel.prototype.markInvalidItems = function (data, invalidProductNames) {
      var self = this;

      for (var i = 0; i &lt; self.items().length; i++) {
        var currentItem = self.items()[i];
        var found = false;
        for (var j = 0; j &lt; data.length; j++) {
          if (data[j].id == currentItem.productId) {
            if (!data[j].active || !data[j].childSKUs || data[j].childSKUs.length == 0) {
              currentItem.invalid = true;
              break;
            } else {
              for (var index = 0; data[j].childSKUs &amp;&amp; index &lt; data[j].childSKUs.length; index++) {
                if (data[j].childSKUs[index].repositoryId == currentItem.catRefId) {
                  found = true;
                  break;
                }
              }
            }
            if (!found) {
              currentItem.invalid = true;
            } else {
              break;
            }
          }
        }
      }
      return false;
    };

    /**
     * Remove items from the cart if they are invalid, or if they are not present in the data parameter.
     *
     * @function
     * @name CartViewMOdel#removeInvalidItems
     * @param {Object[]} data List of items to keep if they are present in the cart.
     * @param {string[]} invalidProductNames  List of names which will be removed from the cart.
     * @returns {boolean} true if any items were removed from the cart, otherwise false.
     */
    CartViewModel.prototype.removeInvalidItems = function (data, invalidProductNames) {
      var self = this;
      var itemsRemovedFromCart = false;
      for (var i = 0; i &lt; self.items().length; i++) {
        var currentItem = self.items()[i];
        var ItemtoBeRemoved = "", found = false, toBeRemoved = false;
        for (var j = 0; j &lt; data.length; j++) {
          if (data[j].id == currentItem.productId) {
            if (!data[j].active || !data[j].childSKUs || data[j].childSKUs.length == 0) {
              toBeRemoved = true;
              ItemtoBeRemoved = data[j].displayName;
              break;
            } else {
              for (var index = 0; data[j].childSKUs &amp;&amp; index &lt; data[j].childSKUs.length; index++) {
                if (data[j].childSKUs[index].repositoryId == currentItem.catRefId) {
                  found = true;
                  break;
                }
              }
            }
            if (!found) {
              toBeRemoved = true;
              ItemtoBeRemoved = data[j].displayName;
            } else {
              break;
            }
          }
        }
        if (!found || toBeRemoved) {
          self.items.remove(currentItem);
          if (invalidProductNames &amp;&amp; ItemtoBeRemoved &amp;&amp; invalidProductNames.indexOf(ItemtoBeRemoved) == -1) {
              invalidProductNames.push(ItemtoBeRemoved);
          }
          itemsRemovedFromCart = true;
          i--;
        }
      }
      return itemsRemovedFromCart;
    };

    /**
     * Updates an item's variant option name and option value
     *
     * @function
     * @name CartViewMOdel#updateItemOptionDetails
     * @param {Object} product Variant Option to be updated for the item.
     * @param {string} sku id of the item.
     */
    CartViewModel.prototype.updateItemOptionDetails = function(productVariantOption, catRefId) {
      // update the cart item selected options information
      for (var i = 0; i &lt; this.items().length; i++) {
        if (this.items()[i].catRefId === catRefId) {
          for (var j = 0; j &lt; this.items()[i].selectedOptions.length; j++) {
            if (this.items()[i].selectedOptions[j].optionId === productVariantOption.optionId) {
              this.items()[i].selectedOptions[j].optionName = productVariantOption.optionName;
              var optionValueMap = productVariantOption.optionValueMap;
              for (var key in optionValueMap) {
                if (optionValueMap[key] === this.items()[i].selectedOptions[j].optionValueId){
                  this.items()[i].selectedOptions[j].optionValue = key;
                  break;
                }
              }
              break;
            }
          }
        }
      }
      // update the local storage shopping cart
      var cookieData = this.getCookieData();
      if (cookieData) {
        var items = cookieData.items;
        for (var k = 0; k &lt; this.items().length; k++) {
          for (var l = 0; l &lt; items.length; l++) {
            if (this.items()[k].catRefId === items[l].catRefId) {
              items[l].selectedOptions = this.items()[k].selectedOptions;
              break;
            }
          }
        }
        cookieData.items = items;
        // Write the shopping cart to local storage
        try {
          storageApi.getInstance().setItem("shoppingCart", JSON.stringify(cookieData));
        }
        catch(pError) {
        }
      }
    };

    /**
     * Locate the shopping cart data in local storage.
     *
     * @private
     * @function
     * @name CartViewModel#getCookieData
     * @returns {Object} Shopping cart data as javascript object.
     */
    CartViewModel.prototype.getCookieData = function() {
      var self = this;
      //load the data from local storage
      var cookieData = null;
      try {
        cookieData = storageApi.getInstance().getItem("shoppingCart");
        if (cookieData &amp;&amp; typeof cookieData == 'string') {
          cookieData = JSON.parse(cookieData);
        }
      }
      catch(pError) {
      }
      return cookieData;
    };

    /**
     * Locate the user data from local storage.
     *
     * @private
     * @function
     * @name CartViewModel#getCookieUserData
     * @returns {Object} User data as javascript object.
     */
    CartViewModel.prototype.getCookieUserData = function() {
      var self = this;
      //load the data from local storage
      var cookieData = null;
      try {
        cookieData = storageApi.getInstance().getItem("user");
        if (cookieData &amp;&amp; typeof cookieData == 'string') {
          cookieData = JSON.parse(cookieData);
        }
      }
      catch(pError) {
      }
      return cookieData;
    };

    /**
     * Check the price data after loading the cart. The loaded cart price is checked with local storage
     * price to check if product price has changed. If the price(list/sale) is different than the local
     * storage data then the page will be redirected to the cart page else it will be redirected to the
     * checkout page.
     *
     * @private
     * @function
     * @name CartViewModel#checkPriceDataAndRedirect
     */
    CartViewModel.prototype.checkPriceDataAndRedirect = function() {
      //check the data with the existing data in local storage to see if the data is correct.
      var self = this;
      var productIds = [];
      for (var i = 0; i &lt; self.items().length; i++) {
        if (productIds.indexOf(self.items()[i].productId) === -1) {
          productIds.push(self.items()[i].productId);
        }
      }

      var catalogId = self.catalogId();
      if(self.user().catalogId()) {
        catalogId = self.user().catalogId();
      }
      var id = new Array(catalogId, productIds, true, SiteViewModel.getInstance().selectedPriceListGroup().id,self.fields);
      var productPriceChanged = false;
      self.adapter.loadJSON('cart', id, null,
      //success callback
      function (data) {
        // Just mark an items as invalid, they'll get cleared from the cart on the next cart load.
        self.markInvalidItems(data, self.invalidProductNames);

        if (self.items().length > 0) {
          var productPriceChanged = self.processCartData(data);
          if (productPriceChanged === true || self.isPricingRequired() ) {
            if (navigation.isPathEqualTo(self.checkoutLink) &amp;&amp; self.shippingMethod() != "") {
              self.priceCartForCheckout();
            } else {
              self.markDirty();
            }
            self.isPricingRequired(false);
          }
          //if product price has changed, then redirect it to the cart page else redirect it to checkout page
          //and also request for repricing
          if (productPriceChanged === true) {
            self.redirect(self.cartLink);
            // As shopper is being redirected to cart page, notify the shopper on that page.
            self.notifyInvalidProducts('cart');
          } else {
            self.validateCartAvailability();
          }
        } else {
          //notify immediately as we are not redirecting
          if (self.isPricingRequired()) {
            self.markDirty();
            self.isPricingRequired(false);
          }
          self.notifyInvalidProducts();
        }
      },
      //error callback
      function (data) {
        if (data.errors &amp;&amp; data.errors.length >0) {
          self.handleListProductsFailure(data);
          self.checkPriceDataAndRedirect();
        }
        self.checkoutWithPaypalClicked(false);
      });
    };

    /**
     * Return an array containing the Product ID of each item in the cart.
     *
     * @function
     * @name CartViewModel#getProductIdsForItemsInCart
     * @return {string[]} List of Product IDs.
     */
    CartViewModel.prototype.getProductIdsForItemsInCart = function() {
      var self = this;
      var productArray = [];
      for (var itemIndex = 0 ; itemIndex &lt; self.items().length; itemIndex++) {
        productArray.push(self.items()[itemIndex].productId);
      }
      return productArray;
     };

    /**
     * Remove invalid products from the cart for each error in the data parameter. (The error objects hold
     *   the product id, which is used to remove items by id.) If items are removed then the cart will
     * be flagged for a price update, and the related error message will be pushed to the invalid product names
     * list.
     *
     * @private
     * @function
     * @name CartViewModel#handleListProductsFailure
     */
    CartViewModel.prototype.handleListProductsFailure = function (data) {
      var self= this;
      for (var i=0; i &lt; data.errors.length ; i++) {
        var error = data.errors[i];
        if (error.errorCode == ccConstants.GET_PRODUCT_NO_PRODUCT_FOUND) {
          var itemsRemovedFromCart = self.removeItemsByProduct(error.moreInfo);
          if (itemsRemovedFromCart) {
            self.isPricingRequired(true);
            if (error.devMessage &amp;&amp; self.invalidProductNames.indexOf(error.devMessage) == -1) {
              self.invalidProductNames.push(error.devMessage);
            }
          }
        }
      }
    };

    /**
     * Helper function called during load cart to load the stock status and quantity orderable values
     * of the cart items via a REST call.
     *
     * @private
     * @function
     * @name CartViewModel#getCartAvailability
     */
    CartViewModel.prototype.getCartAvailability = function () {
      var self= this;
      var availabilityModel = new CartAvailabilityModel(self);
      self.adapter.loadJSON('getStockStatuses', '0', availabilityModel,
        //success callback
        function(data) {
          for (var i = 0; i &lt; self.items().length; i++) {
            for (var j = 0; j &lt; data.length; j++) {
              if ((self.items()[i].productId === data[j].productId) &amp;&amp; (self.items()[i].catRefId === data[j].catRefId)) {
                if (data[j].stockStatus === 'IN_STOCK') {
                  self.items()[i].addLimitsValidation(true, data[j].orderableQuantity);
                } else {
                  self.items()[i].addLimitsValidation(false, data[j].orderableQuantity);
                }
                break;
              }
            }
          }
        },
        //error callback
        function(data) {
          for (var i = 0; i &lt; self.items().length; i++) {
            self.items()[i].addLimitsValidation(false,0);
          }
        }
      );
    };

    /**
     * Checks if the Cart has changed and calls pricing end point if necessary.
     *
     * @private
     * @function
     * @name CartViewModel#priceCartIfNeccessary
     */
    CartViewModel.prototype.priceCartIfNeccessary = function (dirty) {
      var self = this;

      if (dirty) {
        if (self.callbacks &amp;&amp; self.callbacks.hasOwnProperty(ccConstants.PREPRICING) 
            &amp;&amp; typeof self.callbacks[ccConstants.PREPRICING] === 'function') {
          self.callbacks[ccConstants.PREPRICING]();
        }
        if (self.items().length > 0) {
          //If the user is logged-in(header) then persist the items
          if (!navigation.isPathEqualTo(self.checkoutLink) &amp;&amp; self.user() &amp;&amp; self.user().loggedIn() &amp;&amp; !self.user().loggedinAtCheckout()) {
            self.priceItemsAndPersist();
          } 
          //If shipping method exist, reload the shipping options, and price the cart
          else if (!self.callPriceBeforeShippingMethods &amp;&amp; self.shippingMethod()) {
            self.populateShipppingMethods();
          }
          //just price the cart items
          else {
            self.priceItems();
          }
        } else {
          self.emptyCart();
          self.events.pop();
          var user = self.getCookieUserData();
          if (user) {
            self.user().orderId(user.orderId);
          }
          if (self.items().length == 0 &amp;&amp; self.user().loggedIn() &amp;&amp;
              !self.user().loggedinAtCheckout() &amp;&amp; (self.user().orderId() &amp;&amp; self.user().orderId() != '') ) {
            self.removeCurrentProfileOrder();
          }
        }
      }
    };
    
    
    /**
     * trigger RELOAD_SHIPPING_METHODS to reload the shipping options
     */
    CartViewModel.prototype.populateShipppingMethods = function() {
      var self = this;
      if (((self.shippingAddress().afterValidation === false)) || (!self.shippingMethod())) {
        var shippingAddressWithProductIDs = {};
        shippingAddressWithProductIDs[ccConstants.SHIPPING_ADDRESS_FOR_METHODS] = this.shippingAddress();
        shippingAddressWithProductIDs[ccConstants.PRODUCT_IDS_FOR_SHIPPING] = this.getProductIdsForItemsInCart();
        $.Topic(pubsub.topicNames.RELOAD_SHIPPING_METHODS).publishWith(
          shippingAddressWithProductIDs, [ {
          message : "success"
        } ]);
      } else {
        self.priceCartForCheckout();
      }
    };

    /**
     * Price items in cart, update the order id on the user profile and create the order.
     *
     * @private
     * @function
     * @name CartViewModel#privateItemsAndPersist
     */
    CartViewModel.prototype.priceItemsAndPersist = function() {
      var self = this;
      var clearCoupons = false;
      var user = self.getCookieUserData();
      if (user) {
        self.user().orderId(user.orderId);
      }
      if (self.user().loggedIn() &amp;&amp; self.user().orderId() &amp;&amp; self.user().orderId() != '') {
        self.updateCurrentProfileOrder(false, clearCoupons);
      } else {
        self.createCurrentProfileOrder();
      }
    };

    /**
     * Update the current profile order via a REST call.
     *
     * @private
     * @function
     * @name CartViewModel#updateCurrentProfileOrder
     * @param {boolean} merge Whether to merge this order
     * @param {boolean} clearCoupons Whether to clear the coupons on this cart when creating the order.
     */
    CartViewModel.prototype.updateCurrentProfileOrder = function(merge, clearCoupons) {
      var self = this;
      var lastCartEvent = self.events.pop();

      var pricingModel = new CartPricingModel(self);
      self.populateGiftCards(pricingModel,lastCartEvent);
      self.populateDynamicProperties(pricingModel);
      pricingModel.merge = merge;
      pricingModel.clearCoupons = clearCoupons;

      self.adapter.persistUpdate('order', self.user().orderId(), pricingModel,
          //success callback
          function(data) {
            self.isPricingRequired(false);
            self.updateCart(data, lastCartEvent, merge);
            // Incase Shipping Method is already selected ask
            // for reprice for any coupons
            if (self.shippingMethod()) {
              // As the above method triggers another price call, the GWP messages get removed.
              // To avoid this, set a flag to not clear the GWP message.
              self.skipGWPMessage = true;
              self.populateShipppingMethods();
            }
            $.Topic(pubsub.topicNames.COUPON_ADD_CLEAR_INPUT).publish();

          },
          //error callback
          function(data) {
            if (data.status == ccConstants.HTTP_UNAUTHORIZED_ERROR) {
              self.handleSessionExpiry(lastCartEvent);
            } else {
              // Handle coupon apply error
              if (data.errorCode == ccConstants.COUPON_APPLY_ERROR) {
                self.handleCouponPricingError(data, lastCartEvent);
              } else if (data.errorCode == ccConstants.CREATE_ORDER_PRODUCT_NOT_FOUND
                      || data.errorCode == ccConstants.CREATE_ORDER_SKU_NOT_FOUND){
                self.handleInvalidAddItem(data, lastCartEvent);
                // Refresh the cart with last known good data on error
                self.reloadCart();
                self.tax(0);
              } else if (data.errorCode == ccConstants.GIFTCARD_APPLY_ERROR
                  || data.errorCode == ccConstants.GIFTCARD_INSUFFICIENT_ERROR
                  || data.errorCode == ccConstants.INVALID_GIFTCARD_DATA_ERROR
                  || data.errorCode == ccConstants.GIFTCARD_ORDER_PROCESSING_ERROR) {
                self.handleGiftCardError(data);
              } else {
                self.shippingMethod('');
                self.reloadCart();
                self.tax(0);
              }
            }
          }
      );
    };

    /**
     * Check if an error was caused item the user has added being invalid and show a notification if it is.
     *
     * @private
     * @function
     * @name CartViewModel#handleInvalidAddItem
     * @param {Object} data An error object
     * @param {string} data.errorCode The error code.
     * @param {CartEvent} lastCartEvent The most recent cart event.
     */
    CartViewModel.prototype.handleInvalidAddItem = function(data, lastCartEvent) {
      var self = this;
      if (data.errorCode == ccConstants.CREATE_ORDER_PRODUCT_NOT_FOUND
          &amp;&amp; lastCartEvent &amp;&amp; lastCartEvent.type === CART_EVENT_ADD
          &amp;&amp; lastCartEvent.product.id == data.moreInfo
          &amp;&amp; lastCartEvent.product.displayName
          &amp;&amp; self.invalidProductNames.indexOf(lastCartEvent.product.displayName) == -1) {
        self.invalidProductNames.push(lastCartEvent.product.displayName);
      } else if (data.errorCode == ccConstants.CREATE_ORDER_SKU_NOT_FOUND) {
        var moreInfo = JSON.parse(data.moreInfo);
        if (lastCartEvent &amp;&amp; lastCartEvent.type === CART_EVENT_ADD
            &amp;&amp; lastCartEvent.product.id == moreInfo.productId
            &amp;&amp; lastCartEvent.product.childSKUs[0].repositoryId == moreInfo.catRefId
            &amp;&amp; lastCartEvent.product.displayName
            &amp;&amp; self.invalidProductNames.indexOf(lastCartEvent.product.displayName) == -1) {
          self.invalidProductNames.push(lastCartEvent.product.displayName);
        }
      }
    };

    /**
     * Creates the current profile order via a REST call.
     *
     * @function
     * @name CartViewModel#createCureentProfileOrder
     */
    CartViewModel.prototype.createCurrentProfileOrder = function() {
      var self = this;
      var orderState = {incomplete : true};
      if (self.items() &amp;&amp; self.items().length > 0) {
        var lastCartEvent = self.events.pop();
        var pricingModel = new CartPricingModel(self);
        self.populateGiftCards(pricingModel,lastCartEvent);
        self.populateDynamicProperties(pricingModel);

        self.adapter.persistCreate('order', '0', pricingModel, orderState,
            //success callback
            function(data) {
              self.isPricingRequired(false);
              self.updateCart(data, lastCartEvent, false);
              if (self.shippingMethod()) {
                // As the above method triggers another price call, the GWP messages get removed.
                // To avoid this, set a flag to not clear the GWP message.
                self.skipGWPMessage = true;
                self.populateShipppingMethods();
              }
              $.Topic(pubsub.topicNames.COUPON_ADD_CLEAR_INPUT).publish();
            },
            //error callback
            function(data) {
              if (data.status == ccConstants.HTTP_UNAUTHORIZED_ERROR) {
                self.handleSessionExpiry(lastCartEvent);
              } else {
                // Handle coupon apply error
                if (data.errorCode == ccConstants.COUPON_APPLY_ERROR) {
                  self.handleCouponPricingError(data, lastCartEvent);
                } else if (data.errorCode == ccConstants.GIFTCARD_APPLY_ERROR
                    || data.errorCode == ccConstants.GIFTCARD_INSUFFICIENT_ERROR
                    || data.errorCode == ccConstants.INVALID_GIFTCARD_DATA_ERROR
                    || data.errorCode == ccConstants.GIFTCARD_ORDER_PROCESSING_ERROR) {
                  self.handleGiftCardError(data);
                }
                // Refresh the cart with last known good data on error
                self.loadCart();
              }
            }
        );
      }
    };

    //Removes incomplete order for the user.
    /**
     * Remove the current order data on the user profile and persist change via a REST call.
     *
     * @function
     * @name CartViewModel#removeCurrentProfileOrder
     */
    CartViewModel.prototype.removeCurrentProfileOrder = function() {
      var self = this;
      self.adapter.persistRemove('order', self.user().orderId(), null,
          //success callback
          function(data) {
            self.user().orderId('');
            self.user().persistedOrder(null);
            self.user().setLocalData('orderId');
          },
          //error callback
          function(data) {
            // Refresh the cart with last known good data on error
            self.loadCart();
          }
       );
    };

    /**
     * Add a coupon to this cart via the Coupon ID. Look up a coupon by ID and if it is valid
     * add it to the cart.
     *
     * @function
     * @name CartViewModel#addCoupon
     * @param {string} couponId The coupon ID.
     */
    CartViewModel.prototype.addCoupon = function(couponId) {
      var self = this;
      if (couponId) {
        // If product to add is in the cart then simply increase the quantity.
        var cookieData = self.getCookieDataAndCompare();
        var coupon = new Coupon(couponId,'','','','');
        self.events.push(new CartEvent(CART_EVENT_COUPON_ADD , 1, coupon));
        if (cookieData &amp;&amp; !self.isMatchingCookieData()) {
          self.getLocalData(cookieData);
        } else {
          self.addCouponToCart(coupon);
        }
      }
    };

    /**
     * Add a Gift card to the cart and trigger pricing
     *
     * @function
     * @name CartViewModel#addCoupon
     * @param {string} couponId The coupon ID.
     */
    CartViewModel.prototype.addGiftCard = function(giftCardObj) {
      var self = this;
      if (giftCardObj.giftCardNumber &amp;&amp; giftCardObj.giftCardPin) {
        self.giftCards.push(giftCardObj);
        self.events.push(new CartEvent(CART_EVENT_GIFTCARD_ADD , 0, giftCardObj));
        self.markDirty();
      }
    };

    /**
     * This method clears pins of all the giftcards
     */
    CartViewModel.prototype.clearPins = function() {
      var self = this;

      for ( var i = 0; i &lt; self.giftCards().length; i++) {
        var giftCard = self.giftCards()[i];
        giftCard.giftCardPin('');
        giftCard.isPinCleared(true);
        giftCard.isApplyGiftCardClicked(false);
      }

      $.Topic(pubsub.topicNames.GIFTCARD_UPDATE_FROM_CART).publish(
          self.giftCards());
    };


    /**
     * This method re-applies the giftcard pins in the giftcards array
     */
    CartViewModel.prototype.reApplyGiftCardPins = function(giftCard) {
      var self = this;
      self.events.push(new CartEvent(CART_EVENT_GIFTCARD_REAPPLY , 0, giftCard));
      self.markDirty();
    };


    /**
     * This function handles removing a gift card and trigger pricing
     */
    CartViewModel.prototype.removeGiftCard = function(giftCard) {
      var self = this;
      self.giftCards.remove(function(item) { return item.giftCardNumber() == giftCard.giftCardNumber(); });
      self.events.push(new CartEvent(CART_EVENT_GIFTCARD_DELETE , 0, giftCard));
      self.markDirty();
    };
    
    /**
     * Add a coupon object to the cart.
     *
     * @private
     * @function
     * @name CartViewModel#addCouponToCart
     * @param {Coupon} coupon Coupon to add
     */
    CartViewModel.prototype.addCouponToCart = function(coupon) {
      var self = this;
      self.coupons.push(coupon);
      self.couponMultiPromotions.push(new couponMultiPromotion(coupon.code()));
      self.markDirty();
    };

    /**
     * This function handles the functionality of removing a coupon based on the cookie data
     *
     * @function
     * @name CartViewMOdel#removeCoupon
     * @param {Object} couponData Object containing coupon details
     * @param {string} couponData.code The coupon code.
     */
    CartViewModel.prototype.removeCoupon = function(couponData) {
      var self = this;
      if (couponData.code) {
        // If product to add is in the cart then simply increase the quantity.
        var cookieData = self.getCookieDataAndCompare();
        self.events.push(new CartEvent(CART_EVENT_COUPON_DELETE , 0, couponData));
        if (cookieData &amp;&amp; !self.isMatchingCookieData()) {
          self.getLocalData(cookieData);
        } else {
          self.removeCouponFromCart(couponData);
        }
      }
    };

    /**
     * Remove coupon from cart.
     *
     * @private
     * @function
     * @CartViewModel#removeCouponFromCart
     * @param {Coupon} couponData Object containing coupon details.
     */
    CartViewModel.prototype.removeCouponFromCart = function(couponData) {
      var self = this;
      self.coupons.remove(function(item) { return item.code() == couponData.code(); });
      self.couponMultiPromotions.remove(function(item) { return item.code() == couponData.code(); });
      self.markDirty();
    };

    /**
     * Handle session expiry occurring suring cart updates.
     *
     * @private
     * @function
     * @name CartViewModel#handleSessionExpiry
     * @param {CartEvent} lastCartEvent Most recent cart event.
     */
    CartViewModel.prototype.handleSessionExpiry = function (lastCartEvent) {
      var self = this;
      if (lastCartEvent &amp;&amp; lastCartEvent.type === CART_EVENT_ADD) {
        var product = lastCartEvent.product;
        var addItemToCart = self.addToCart.bind(product);
        addItemToCart();
      } else if(lastCartEvent &amp;&amp; (lastCartEvent.type === CART_EVENT_UPDATE
              || lastCartEvent.type === CART_EVENT_DELETE || lastCartEvent.type === CART_EVENT_COUPON_ADD
              || lastCartEvent.type === CART_EVENT_COUPON_DELETE) &amp;&amp; navigation.isPathEqualTo(self.cartLink)) {
        notifier.sendError(CART_VIEW_MODEL_ID, CCi18n.t('ns.common:resources.cartSessionExpired'), true);
        self.user().clearUserData();
      } else if(lastCartEvent &amp;&amp; (lastCartEvent.type === CART_EVENT_COUPON_ADD
          || lastCartEvent.type === CART_EVENT_COUPON_DELETE) &amp;&amp; navigation.isPathEqualTo(self.checkoutLink)) {
        self.isDirty(false);
        self.markDirty();
      }
    };

    /**
     * Handle error with coupon pricing.
     *
     * @private
     * @function
     * @name CartViewModel#handleCouponPricingError
     * @param {Object} errorData Object containing error data.
     * @param {string} errorData.message Error message.
     * @param {string} errorData.moreInfo Coupon code.
     * @param {CartEvent} lastCartEvent Most recent cart event.
     */
    CartViewModel.prototype.handleCouponPricingError = function(errorData, lastCartEvent) {
      var self = this;
      // set error message when there is an error while adding a coupon
      if (errorData.message &amp;&amp; lastCartEvent &amp;&amp; (lastCartEvent.type === CART_EVENT_COUPON_ADD)
          &amp;&amp; (self.coupons()[self.coupons().length - 1].code() == errorData.moreInfo)) {
        self.couponErrorMessage(errorData.message);
      } else if (errorData.message &amp;&amp; (!lastCartEvent || lastCartEvent.type != CART_EVENT_COUPON_ADD)) {
    	  notifier.sendError(CART_VIEW_MODEL_ID, CCi18n.t('ns.common:resources.orderPricingPromotionError'), true);
      }
      // moreInfo property of error data contains coupon code when there is a coupon add/claim error
      if (errorData.moreInfo) {
        self.isDirty(false);
        self.coupons.remove(function(item) { return item.code() == errorData.moreInfo; });
        self.couponMultiPromotions.remove(function(item) { return item.code() == errorData.moreInfo; });
        self.markDirty();
      }
    };

    /**
     * 
     * @private
     * @function
     * @name CartViewModel#handleCurrencyPricingError
     */
    CartViewModel.prototype.handleCurrencyPricingError = function() {
       var self = this;
       self.cartPriceListGroupId(SiteViewModel.getInstance().selectedPriceListGroup().id);
       //Setting to default price list group in storage which will be picked by request header
       ccRestClient.setStoredValue(ccConstants.LOCAL_STORAGE_PRICELISTGROUP_ID, ko.toJSON(SiteViewModel.getInstance().selectedPriceListGroup().id));
       self.isDirty(false);
       self.markDirty();
    };

    /**
     * Calls the pricing endpoint and updates CartItems with returned price information
     *
     * @name CartViewModel#priceItems
     */
    CartViewModel.prototype.priceItems = function() {
      var self = this;

      var lastCartEvent = self.events.pop();


      var pricingModel = new CartPricingModel(self);
      self.populateGiftCards(pricingModel,lastCartEvent);

      self.adapter.persistCreate(ccConstants.ENDPOINT_ORDERS_PRICE_ORDER, '0', pricingModel,
        //success callback
        function(data) {
          self.isPricingRequired(false);
          self.updateCart(data, lastCartEvent, false);
          if(self.callPriceBeforeShippingMethods) {
            self.populateShipppingMethods();
          }
          $.Topic(pubsub.topicNames.COUPON_ADD_CLEAR_INPUT).publish();
        },
        //error callback
        function(data) {
         if(data.errorCode == ccConstants.SELECTED_CURRENCY_NOT_FOUND) {
             //Handling error of currency not being found.
             self.handleCurrencyPricingError();
         } else if (data.errorCode == ccConstants.COUPON_APPLY_ERROR) {
            // Handle coupon related error
            self.handleCouponPricingError(data, lastCartEvent);
          } else if (data.errorCode == ccConstants.CREATE_ORDER_PRODUCT_NOT_FOUND
                  || data.errorCode == ccConstants.CREATE_ORDER_SKU_NOT_FOUND){
            self.handleInvalidAddItem(data, lastCartEvent);
            // Refresh the cart with last known good data on error
            self.loadCart();
            self.tax(0);
          } else if (data.errorCode == ccConstants.GIFTCARD_APPLY_ERROR
              || data.errorCode == ccConstants.GIFTCARD_INSUFFICIENT_ERROR
              || data.errorCode == ccConstants.INVALID_GIFTCARD_DATA_ERROR
              || data.errorCode == ccConstants.GIFTCARD_ORDER_PROCESSING_ERROR) {
        	  self.handleGiftCardError(data,lastCartEvent);
          } else if (data.errorCode == ccConstants.ANONYMOUS_USER_ACCESS_CONTROL_ERROR) {
            notifier.sendError('UserNotAuthorized', CCi18n.t('ns.common:resources.anonymousAccessControlError'), true);
          } else {
            self.loadCart();
            self.tax(0);
          }
        }
      );
    };

    /**
     * &lt;p>
     *   Determine if, when in single shipping mode (i.e. isSplitShipping == false), single shipping address 
     *  and shipping method are populated.
     * &lt;/p>
     *
     * @function
     * @name CartViewModel#hasSingleShippingInformation
     * @return {boolean} true if single shipping mode is selected &lt;b>and&lt;/b> all single shiping options are 
     *    populated, false otherwise.
     */
    CartViewModel.prototype.hasSingleShippingInformation = function () {
      var hasSingleShippingInformation = false;

      if (!this.isSplitShipping()) {
        hasSingleShippingInformation = this.shippingAddress() !== '' &amp;&amp; this.shippingMethod() !== '';
      }

      return hasSingleShippingInformation;
    };

    /**
     * &lt;p>
     *   Determine if, when in split shipping mode (i.e. isSplitShipping == true) all shipping 
     *   group relationships are populated with shipping addresses and shipping methods, and the 
     *   shippingGroupRelationships array is valid (see shippingGroupRelationships validators for details).
     * &lt;/p>
     *
     * @function
     * @name CartViewModel#hasSplitShippingInformation
     * @return {boolean} true if split shipping mode is selected &lt;b>and&lt;/b> all split shiping options are 
     *    populated and valid, false otherwise.
     */
    CartViewModel.prototype.hasSplitShippingInformation = function () {
      var hasSplitShippingInformation = false;

      if (this.isSplitShipping()) {
        hasSplitShippingInformation = this.items().every(function (cartItem) {
          return cartItem.shippingGroupRelationships.isValid() &amp;&amp; cartItem.shippingGroupRelationships().every(function (shippingGroupRelationship) {
            return shippingGroupRelationship.shippingAddress() &amp;&amp; shippingGroupRelationship.shippingMethod();
          });
        });
      }

      return hasSplitShippingInformation;
    };

    /**
     * &lt;p>
     *   Determine if the cart is populated with shipping information. This method delegates to 
     *   CartViewModel#hasSingleShippingInformation and CartViewModel#hasSplitShippingInformation.
     * &lt;/p>
     *
     * @function
     * @name CartViewModel#hasShippingInformation
     * @return {boolean} true if CartViewModel#hasSingleShippingInformation or 
     *    CartViewModel#hasSplitShippingInformation is true, false otherwise.
     */
    CartViewModel.prototype.hasShippingInformation = function () {
      var hasShippingInformation = this.hasSplitShippingInformation() || this.hasSingleShippingInformation();

      return hasShippingInformation;
    };


    /**
     * Calls the pricing endpoint and updates CartItems with returned price information
     *
     * @name CartViewModel#priceCartForCheckout
     */
    CartViewModel.prototype.priceCartForCheckout = function() {
      var self = this;
      var lastCartEvent = self.events.pop();

      //check if shipping address and shipping options are not blank
      if (self.hasShippingInformation()) {
        var pricingModel = new CartPricingModel(self);

        if (this.isSplitShipping()) {
          pricingModel.shippingGroups = this.createShippingGroups();
        }
        else {
          pricingModel.shippingMethod = {value: this.shippingMethod()};
          pricingModel.shippingAddress = this.shippingAddress();
        }
        pricingModel.populateShippingMethods = true;
        self.populateGiftCards(pricingModel,lastCartEvent);

        if (self.items().length > 0) {
          self.adapter.loadJSON('orderPricing', '0', pricingModel,
            function(data) {
              self.isPricingRequired(false);
              self.updateCart(data, lastCartEvent, false);
              $.Topic(pubsub.topicNames.ORDER_PRICING_SUCCESS).publish([{message: "success"}]);
              $.Topic(pubsub.topicNames.COUPON_ADD_CLEAR_INPUT).publish();
            },
            function(data) {
              if(data.errorCode == ccConstants.SELECTED_CURRENCY_NOT_FOUND) {
                 //Handling error of currency not being found.
                 self.handleCurrencyPricingError();
              } else if (data.errorCode == ccConstants.COUPON_APPLY_ERROR) {
                 //Handle coupon related error
                self.handleCouponPricingError(data, lastCartEvent);
              } else if (data.errorCode == ccConstants.CREATE_ORDER_PRODUCT_NOT_FOUND
                  || data.errorCode == ccConstants.CREATE_ORDER_SKU_NOT_FOUND) {
                self.loadCart();
                self.tax(0);
              } else if (data.errorCode == ccConstants.GIFTCARD_APPLY_ERROR
                  || data.errorCode == ccConstants.GIFTCARD_INSUFFICIENT_ERROR
                  || data.errorCode == ccConstants.INVALID_GIFTCARD_DATA_ERROR
                  || data.errorCode == ccConstants.GIFTCARD_ORDER_PROCESSING_ERROR) {
                self.handleGiftCardError(data,lastCartEvent);
              } else {
                self.shippingMethod('');
                self.loadCart();
                self.tax(0);
                $.Topic(pubsub.topicNames.ORDER_PRICING_FAILED).publishWith(data);
              }
              
              $.Topic(pubsub.topicNames.DESTROY_SHIPPING_METHODS_SPINNER).publishWith(data);
            }
          );
        } else {
          self.emptyCart();
          $.Topic(pubsub.topicNames.ORDER_PRICING_FAILED).publish();
        }
      }
    };


    /**
     * handles the failure of applying gift cards to cart.
     */
    CartViewModel.prototype.handleGiftCardError = function(data,lastCartEvent) {
      var self = this;
      var giftCardObj = lastCartEvent.product;

      if(lastCartEvent.type ===  CART_EVENT_GIFTCARD_ADD)
      	{
    	  self.giftCards.remove(function(item) { return item.giftCardNumber() == giftCardObj.giftCardNumber(); });
      	}
      	else if( lastCartEvent.type ===  CART_EVENT_GIFTCARD_REAPPLY  &amp;&amp; data.errorCode == ccConstants.GIFTCARD_INSUFFICIENT_ERROR){
      		self.giftCards.remove(function(item) { return item.giftCardNumber() == giftCardObj.giftCardNumber(); });
      		$.Topic(pubsub.topicNames.GIFTCARD_UPDATE_FROM_CART).publish(
    		          self.giftCards());
      		self.isDirty(false);
      		self.isDirty(true);
    	  }


      $.Topic(pubsub.topicNames.GIFTCARD_PRICING_FAILED).publish(data,
          giftCardObj,lastCartEvent);
      self.isDirty(false);
    };


    /**
     * Populates CartViewModel with passed in data
     *
     * @name CartViewModel#updateCart
     * @param {Object} data The JSON data received from the server.
     * @param {CartEvent} lastCartEvent Most recent cart event.
     * @param {boolean} merge
     */
    CartViewModel.prototype.updateCart = function(data, lastCartEvent, merge) {
      var self = this;
      if (merge || self.items().length > 0) {
        
        self.updateCartData(data, merge);
        self.updateGiftCardDetails(data, lastCartEvent);
        self.updateDynamicProperties(data);
        self.cartUpdated();
        ////Publishing price complete when pricing is finished
        $.Topic(pubsub.topicNames.CART_PRICE_COMPLETE).publish();
        // Actually CART_ADD_SUCCESS should be published after the cart has been updated and ready
        // But as no such flag is available, I am shifting this event to end of this function.
        if (lastCartEvent &amp;&amp; lastCartEvent.type === CART_EVENT_ADD) {
          $.Topic(pubsub.topicNames.CART_ADD_SUCCESS).publish(lastCartEvent.product);
        }
      }
    };

    /**
     * This method updates the giftcard details from the response to cart
     * and then publishes to Order
     */
      CartViewModel.prototype.updateGiftCardDetails = function(data,lastCartEvent) {
        var self = this;
        var gcToBeRemoved = [];
        if (data.payments &amp;&amp; self.giftCards().length > 0) {
          for ( var i = 0; i &lt; self.giftCards().length; i++) {
            var found = false;
            var giftCard = self.giftCards()[i];
            for ( var j = 0; j &lt; data.payments.length; j++) {
              var giftCardPayment = data.payments[j];
              if (giftCardPayment.paymentMethod == ccConstants.GIFT_CARD_PAYMENT_TYPE
                  &amp;&amp; giftCard.giftCardNumber() == giftCardPayment.giftCardNumber) {
                giftCard.amountInGiftCard(giftCardPayment.balance);
                giftCard.amountUsed(giftCardPayment.amount);
                giftCard.isAmountRemaining(giftCardPayment.isAmountRemaining);
                giftCard.maskedGiftCardNumber(giftCardPayment.maskedCardNumber);
                giftCard.isApplyGiftCardClicked(false);
                found = true;
                break;
              }
            }

            if (lastCartEvent &amp;&amp; lastCartEvent.product &amp;&amp; lastCartEvent.product.giftCardNumber &amp;&amp; lastCartEvent.product.giftCardNumber() === giftCard.giftCardNumber()) {
            	giftCard.isPinCleared(false);
            }

            if (found == false) {
              gcToBeRemoved.push(giftCard);
            }
          }
          for ( var k = 0; k &lt; gcToBeRemoved.length; k++) {
            self.giftCards
                .remove(function(item) {
                  return item.giftCardNumber() == gcToBeRemoved[k]
                      .giftCardNumber();
                });
          }
          if (gcToBeRemoved &amp;&amp; gcToBeRemoved.length > 0) {
            notifier.sendError(CART_VIEW_MODEL_ID, CCi18n
                .t('ns.common:resources.orderPricingPromotionError'), true);
          }

        }
        $.Topic(pubsub.topicNames.GIFTCARD_UPDATE_FROM_CART).publish(
            self.giftCards());
        self.updateRemainingAmount(data);
      };
    
    /**
     * This method updates the remaining amount to be paid after applying the gift cards
     * and then publishes to Order
     */
      CartViewModel.prototype.updateRemainingAmount = function(data) {
        var self = this;
        var amountRemaining = null;
        if (data.payments &amp;&amp; self.giftCards().length > 0) {
          for ( var j = 0; j &lt; data.payments.length; j++) {
            var giftCardPayment = data.payments[j];
            if (giftCardPayment.isAmountRemaining == true) {
              if (giftCardPayment.paymentMethod == ccConstants.GIFT_CARD_PAYMENT_TYPE) {
                amountRemaining = 0;
              } else {
                amountRemaining = giftCardPayment.amount;
              }
              break;
            }
          }
        }
        $.Topic(pubsub.topicNames.UPDATE_AMOUNT_REMAINING).publish(
            amountRemaining);
      };
    
    /**
     * Update Cart after receiving data from the server.
     *
     * @private
     * @function
     * @name CartViewModel#updateCartData
     */
    CartViewModel.prototype.updateCartData = function(data, merge) {
      var self = this;
      if (data &amp;&amp; data.orderId) {
        self.user().orderId(data.orderId);
        self.user().setLocalData('orderId');
      }
     
      var reloadCart = updateItems(data.shoppingCart.items, self.items, merge, self, data);
      // As self.items are updated, now check if all the items have productData.
      for (var i = 0; i &lt; self.items().length; i++) {
        if (self.items()[i].productData() == null) {
          self.getProductData();
          break;
        }
      }

      self.numberOfItems(data.shoppingCart.numberOfItems);
      self.total(data.priceInfo.total);
      self.totalWithoutTax(data.priceInfo.totalWithoutTax);
      self.subTotal(data.priceInfo.subTotal);
      self.shipping(data.priceInfo.shipping);
      self.tax(data.priceInfo.tax);
      self.currencyCode(data.priceInfo.currencyCode);
      self.shippingSurcharge(data.priceInfo.shippingSurchargeValue);
      if (data.discountInfo) {
        if (data.discountInfo.orderDiscount) {
          self.orderDiscount(data.discountInfo.orderDiscount);
        }
        else {
          self.orderDiscount(0);
        }
        if(data.discountInfo.shippingDiscount) {
          self.shippingDiscount(data.discountInfo.shippingDiscount);
        }
        else {
          self.shippingDiscount(0);
        }

        if (data.discountInfo.orderImplicitDiscountList) {
          self.orderDiscountDescList(data.discountInfo.orderImplicitDiscountList);
        }


        if (data.discountInfo.unclaimedCouponsMap) {
          self.populateCoupons(data.discountInfo.unclaimedCouponsMap, ccConstants.COUPON_STATUS_UNCLAIMED);
        }

        if (data.discountInfo.orderCouponsMap) {
          self.populateCoupons(data.discountInfo.orderCouponsMap, ccConstants.COUPON_STATUS_CLAIMED);
        }

        self.couponMultiPromotions.splice(0);
        if (data.discountInfo.unclaimedCouponMultiPromotions) {
          self.populateCouponMultiPromotions(data.discountInfo.unclaimedCouponMultiPromotions, ccConstants.COUPON_STATUS_UNCLAIMED, ccConstants.PROMOTION_NOT_APPLIED);
        }

        if (data.discountInfo.claimedCouponMultiPromotions) {
            self.populateCouponMultiPromotions(data.discountInfo.claimedCouponMultiPromotions, ccConstants.COUPON_STATUS_CLAIMED, ccConstants.PROMOTION_APPLIED);
        }

        self.populateClaimedCouponMultiPromotions(self.couponMultiPromotions());
        // Clear up coupons that are no longer coming from the server
        for (var i=self.coupons().length-1;i>=0;i--) {
          if (!data.discountInfo.orderCouponsMap.hasOwnProperty(self.coupons()[i].code()) &amp;&amp; !data.discountInfo.unclaimedCouponsMap.hasOwnProperty(self.coupons()[i].code())) {
            self.coupons.splice(i,1);
          }
        }

        if(data.shippingGroups) {
          self.orderShippingGroups(data.shippingGroups);
        }
        else {
          self.shippingDiscount([]);
        }
      }
      //this change is required to avoid the pricing being called infinately, as this amount is subscribed in chekcout order summary
      self.amount(data.priceInfo.amount);

      if (!self.skipGWPMessage) {
        self.sendGWPMessages(data);
      }
      self.skipGWPMessage = false;


      self.giftWithPurchaseOrderMarkers = data.giftWithPurchaseOrderMarkers;
      // Gift item to select
      self.placeHolderItems.removeAll();
      if (data.giftWithPurchaseInfo &amp;&amp; data.giftWithPurchaseInfo.length) {
        self.updatePlaceHolderItems(data.giftWithPurchaseInfo);
      }

      return reloadCart;
    };

    /**
     * Adds gift data to a cart item if gift choices are available.
     *
     * @private
     * @function
     * @name CartViewModel#addGiftDataToItem
     */
    CartViewModel.prototype.addGiftDataToItem = function (item, data) {
      var self = this;

      if (item.discountInfo().length) {
        var discountInfo = item.discountInfo();
        item.giftData = [];
        for (var i = 0; i &lt; discountInfo.length; i++) {
          if (discountInfo[i].giftWithPurchaseDiscountInfo &amp;&amp; discountInfo[i].giftWithPurchaseDiscountInfo.length) {
            for (var j = 0; j &lt; discountInfo[i].giftWithPurchaseDiscountInfo.length; j++) {
              var giftWithPurchaseDiscountInfo = discountInfo[i].giftWithPurchaseDiscountInfo[j];
              if (giftWithPurchaseDiscountInfo.giftWithPurchaseChoicesAvailable) {
                var giftWithPurchaseIdentifier = giftWithPurchaseDiscountInfo.giftWithPurchaseIdentifier;
                // Now search in giftWithPurchaseInfo with this hash code to get giftWithPurchaseType and giftWithPurchaseDetail
                for (var k = 0; k &lt; data.giftWithPurchaseInfo.length; k++) {
                  if (data.giftWithPurchaseInfo[k].giftWithPurchaseIdentifier == giftWithPurchaseIdentifier &amp;&amp;
                      data.giftWithPurchaseInfo[k].promotionId == discountInfo[i].promotionId) {
                    var giftData = {};
                    giftData.giftWithPurchaseType = data.giftWithPurchaseInfo[k].giftWithPurchaseType;
                    giftData.giftWithPurchaseDetail = data.giftWithPurchaseInfo[k].giftWithPurchaseDetail;
                    giftData.promotionId = data.giftWithPurchaseInfo[k].promotionId;
                    giftData.giftWithPurchaseIdentifier = data.giftWithPurchaseInfo[k].giftWithPurchaseIdentifier;
                    giftData.giftWithPurchaseQuantity = giftWithPurchaseDiscountInfo.giftWithPurchaseQuantity;
                    item.giftData.push(giftData);
                    item.isGWPChoicesAvaliable(true);
                    break;
                  }
                }
              }
            }
          }
        }
      }
    };

    /**
     * Adds items to placeHolderItems array based on gift availability.
     *
     * @private
     * @function
     * @name CartViewModel#updatePlaceHolderItems
     */
    CartViewModel.prototype.updatePlaceHolderItems = function (giftWithPurchaseInfo) {
      var self = this;

      for (var i = 0; i &lt; giftWithPurchaseInfo.length; i++) {
        if (giftWithPurchaseInfo[i].giftWithPurchaseQuantityAvailableForSelection) {
          var giftWithPurchaseQuantity = giftWithPurchaseInfo[i].giftWithPurchaseQuantityAvailableForSelection;
          if (giftWithPurchaseQuantity) {
            var placeHolderData = giftWithPurchaseInfo[i];
            placeHolderData.displayName = CCi18n.t('ns.common:resources.freeProductText');
            placeHolderData.imageData = {
              'primaryThumbImageURL' : "/img/GWP_GiftWithPurchase.jpg",
              'primaryImageAltText' : placeHolderData.displayName,
              'primaryImageTitle' : placeHolderData.displayName,
            };
            placeHolderData.quantity = 1;
            placeHolderData.itemTotal = 0;
            placeHolderData.quantityDisabled = true;
            placeHolderData.id = Math.floor(Math.random() * 10000);
            placeHolderData.isPlaceHolderItem = true;
          }
          while (giftWithPurchaseQuantity) {
            self.placeHolderItems.push(placeHolderData);
            giftWithPurchaseQuantity --;
          }
        }
      }
      self.numberOfItems(self.numberOfItems() + self.placeHolderItems().length);
    };

    /**
     * Remove the given place holder item from the cart.
     *
     * @private
     * @function
     * @name CartViewModel#removePlaceHolderFromCart
     */
    CartViewModel.prototype.removePlaceHolderFromCart = function (item) {
      var self = this;
      self.placeHolderItems.remove(item);
      self.allItems.remove(item);
      $.Topic(pubsub.topicNames.CART_REMOVE_SUCCESS).publishWith([{message:"success"}]);
      self.numberOfItems(self.numberOfItems() - 1);
    };

    CartViewModel.prototype.sendGWPMessages = function(data) {
      var self = this;

      notifier.clearError(GIFT_WITH_PURCHASE_ID);

      if (self.gwpQualified) {
        $.Topic(pubsub.topicNames.GWP_CLEAR_QUALIFIED_MESSAGE).publish();
        self.gwpQualified = false;
      }

      if (data.pricingMessages &amp;&amp; data.pricingMessages.giftWithPurchaseMessages
          &amp;&amp; data.pricingMessages.giftWithPurchaseMessages.length) {
        var gwpMessages = data.pricingMessages.giftWithPurchaseMessages
        // gwpInvalidated flag to notify the shopper only once
        var gwpInvalidated = false;
        // gwpFailure flag to notify the shopper only once
        var gwpFailure = false;
        var promotionId = null;
        for (var i = 0; i &lt; gwpMessages.length; i++) {
          if ((gwpMessages[i].identifier == "GWPFullFailure") &amp;&amp; !gwpFailure) {
            notifier.sendError(GIFT_WITH_PURCHASE_ID, gwpMessages[i].summary, true);
            gwpFailure = true;
            // As messages are queued, so both failure and qualified messages are sent.
            // To avoid displaying qualified message in case of failure, need to check the promotion id.
            // Right now checking only for the first promotionId. Might need to change it later.
            if (gwpMessages[i].params[0] == promotionId) {
              $.Topic(pubsub.topicNames.GWP_CLEAR_QUALIFIED_MESSAGE).publish();
              self.gwpQualified = false;
              promotionId = null;
            } else {
              promotionId = gwpMessages[i].params[0];
            }
            $.Topic(pubsub.topicNames.GWP_FAILURE_MESSAGE).publish(gwpMessages[i]);
          } else if ((gwpMessages[i].identifier == "GWPQualified") &amp;&amp; !self.gwpQualified) {
            $.Topic(pubsub.topicNames.GWP_QUALIFIED_MESSAGE).publish(gwpMessages[i]);
            // gwpQualified flag so that GWPQualified is published only once
            self.gwpQualified = true;
            if (promotionId == gwpMessages[i].params[0]) {
              $.Topic(pubsub.topicNames.GWP_CLEAR_QUALIFIED_MESSAGE).publish();
              self.gwpQualified = false;
              promotionId = null;
            } else {
              promotionId = gwpMessages[i].params[0];
            }
          } else if ((gwpMessages[i].identifier == "GWPInvalidated") &amp;&amp; !gwpInvalidated) {
            notifier.sendError(GIFT_WITH_PURCHASE_ID, gwpMessages[i].summary, true);
            gwpInvalidated = true;
            $.Topic(pubsub.topicNames.GWP_INVALIDATED_MESSAGE).publish(gwpMessages[i]);
          }
        }
      }
    };

    /**
     * Populate coupons on cart using a map of coupons that maps a coupon code onto an object containing
     * related coupon details. All coupons on the cart will have status given by the status parameter.
     *
     * @private
     * @function
     * @name CartViewModel#populateCoupons
     * @param {Object} coupons map A set of coupon codes mapping onto Objects containing {promotionDesc, promotionLevel, promotionId, totalAdjustment}
     * @param {string} status Status to set on all coupons in cart.
     */
    CartViewModel.prototype.populateCoupons = function(couponsMap, status) {
      var self = this;
      var couponsToAdd = [], found =false;;
      var couponsCount = self.coupons().length;
      for (var key in couponsMap){
        for (var i = 0; i &lt; couponsCount; i++) {
          if (key == self.coupons()[i].code()) {
            self.coupons()[i].description(couponsMap[self.coupons()[i].code()].promotionDesc);
            self.coupons()[i].status(status);
            self.coupons()[i].level(couponsMap[self.coupons()[i].code()].promotionLevel);
            self.coupons()[i].id(couponsMap[self.coupons()[i].code()].promotionId);
    		self.coupons()[i].totalAdjustment(couponsMap[self.coupons()[i].code()].totalAdjustment);
            found = true;
            break;
          }
        }
        if (!found) {
          couponsToAdd.push(new Coupon(key, couponsMap[key].promotionDesc, status, couponsMap[key].promotionLevel, couponsMap[key].promotionId, couponsMap[key].totalAdjustment));
        }
      }
      for (var i = 0; i &lt; couponsToAdd.length; i++) {
        self.coupons.push(couponsToAdd[i]);
      }
    };

    /**
     * Populate coupons on cart using an object containing coupon code as the key, and a list of promotions associated with the coupon as value.
     * 
     * @function
     * @name CartViewModel#populateCouponMultiPromotions
     * @param {Object} sourceCoupons Object containing coupon code as key, and associated list of promotions as value
     * @param {String} couponStatus Status to be set on the coupons.
     * @param {Boolean} promotionApplied true, if the promotion is applied to the order
     */
    CartViewModel.prototype.populateCouponMultiPromotions = function(sourceCoupons, couponStatus, promotionApplied) {
      var self = this;
      var couponsToAdd = [], couponFound =false;
      var couponsCount = self.couponMultiPromotions().length;
      for (var key in sourceCoupons){
        couponFound = false;
        for (var i = 0; i &lt; couponsCount; i++) {
          if (key == self.couponMultiPromotions()[i].code()) {
            self.couponMultiPromotions()[i].couponStatus(couponStatus);
            self.couponMultiPromotions()[i].populateCouponData(sourceCoupons[key], promotionApplied);
            couponFound = true;
            break;
          }
        }
        if (!couponFound) {
          couponsToAdd.push(new couponMultiPromotion(key, sourceCoupons[key], couponStatus, promotionApplied));
        }
      }
      for (var i = 0; i &lt; couponsToAdd.length; i++) {
        self.couponMultiPromotions.push(couponsToAdd[i]);
      }
    };

    /**
     * Filters the couponMultiPromotions array, and save all the claimed coupons, along with applied promotions in a separate array
     * 
     * @function
     * @name CartViewModel#populateClaimedCouponMultiPromotions
     * @param {observableArray} couponMultiPromotions An array containing the coupons, along with associated promotions available in cart
     */
    CartViewModel.prototype.populateClaimedCouponMultiPromotions = function(couponMultiPromotions) {
      var self = this;
      self.claimedCouponMultiPromotions.splice(0);
      for (var couponIndex = 0; couponIndex &lt; couponMultiPromotions.length; couponIndex++) {
        if(couponMultiPromotions[couponIndex].couponStatus() === ccConstants.COUPON_STATUS_CLAIMED) {
          var sourcePromotions = [];
          for(var promoIndex = 0; promoIndex &lt; couponMultiPromotions[couponIndex].promotions().length; promoIndex++) {
            if(couponMultiPromotions[couponIndex].promotions()[promoIndex].promotionApplied()) {
              sourcePromotions.push(ko.mapping.toJS(couponMultiPromotions[couponIndex].promotions()[promoIndex]));
            }
          }
          self.claimedCouponMultiPromotions.push(new couponMultiPromotion(couponMultiPromotions[couponIndex].code(), sourcePromotions, ccConstants.COUPON_STATUS_CLAIMED, ccConstants.PROMOTION_APPLIED));
        }
      }
    }
    
    /**
     * This method populate shipping methods for the given shippingGroupRelationship. 
     * Before calling shipping methods, it calls price endpoint to get rawTotalPrice of that shippingGroup.
     *  
     */
    CartViewModel.prototype.populateShippingMethodsForShippingGroup = function (shippingGroupRelationship, successFunction, errorFunction) {
      var self = this;
      var priceInput = {};
      priceInput.shoppingCart = {};    	
      priceInput.shoppingCart.items = [];    
      
      // Get the current shipping group item details to get rawTotalPrice
      priceInput.shoppingCart.items.push({
        catRefId: shippingGroupRelationship.catRefId,
    	productId: shippingGroupRelationship.productId,
    	quantity: shippingGroupRelationship.quantity()
      });
    	
      self.adapter.persistCreate(ccConstants.ENDPOINT_ORDERS_PRICE_ORDER, '0', priceInput,
    	  //success callback
    	  function(data) {
    		// Build service request arguments.
            var inputParams = {};
            var shippingAddress = shippingGroupRelationship.shippingAddress();

            // Can only lookup shipping options if a shipping address has been selected.
            if (shippingAddress) {
              inputParams[ccConstants.PRODUCT_IDS_FOR_SHIPPING] = [shippingGroupRelationship.productId];
              inputParams[ccConstants.POPULATE_SHIPPING_METHODS] = true;
              inputParams[ccConstants.SHIPPING_ADDRESS_FOR_METHODS] = shippingAddress.toJSON();
              
              // Sending PriceInfo with entire cart (all items total) details.
              inputParams.priceInfo =  {
          			amount: self.amount(),
        			total: self.total(),
        			shipping: self.shipping(),
        			totalWithoutTax: self.totalWithoutTax(),
        			currencyCode: self.currencyCode(),
        			shippingSurchargeValue: self.shippingSurcharge(),
        			tax: self.tax(),
        			subTotal: self.subTotal() 
        		  }; 
              var targetItems = ko.observableArray();
              
              updateItems(data.shoppingCart.items, targetItems, true);
              
              inputParams.items = targetItems();

              // Empty the current shipping options.
              shippingGroupRelationship.shippingOptions.removeAll();

              // Call service
              self.adapter.persistCreate(
                // URL
            	ccConstants.ENDPOINT_SHIPPING_METHODS_LIST_SHIPPING_METHODS,
                'id',
                // Request arguments.
                inputParams,
                // Success callback.
                function success (data) { 
                  successFunction(data);
                },
                // Error callback.
                function error (data) {
                  errorFunction(data);
                });
              }
   	        },
    	    //error callback
    	    function(data) {
    	      errorFunction(data);
    	    });	
     
    };
    /**
     * Helper Model for sending coupon info for pricing.
     *
     * @private
     * @class Represents a coupon.
     * @name Coupon
     * @property {observable&lt;string>} code coupon code
     * @property {observable&lt;string>} description promotion description
     *
     */
    function Coupon(code, description, status, level, promotionId, totalAdjustment) {
      var self =this;
      self.code = ko.observable(code);
      self.description = ko.observable(description);
      self.status = ko.observable(status);
      self.level = ko.observable(level);
      self.id = ko.observable(promotionId);
      self.totalAdjustment = ko.observable(totalAdjustment);

      self.toJSON = function() {
        var copy = ko.toJS(self);
        return copy;
      };
      return self;
    };

    /**
     * Creates a coupon that supports multiple promotions
     *
     * @param {String} couponCode coupon code
     * @param {Array} sourcePromotions promotions that will be associated to the coupon code
     * @param {String} couponStatus status that will be associated to the coupon
     * @param {Boolean} true, if the promotion is applied to the order
     *
     */
    function couponMultiPromotion(couponCode, sourcePromotions, couponStatus, promotionApplied) {
      var self =this;
      self.code = ko.observable(couponCode);
      self.couponStatus = ko.observable(couponStatus?couponStatus:'');
      self.promotions = ko.observableArray([]);

      /**
       * Creates a new Promotion, that will be associated with the coupon
       * @param {String} promotionId The id for the promotion
       * @param {String} description The description for the promotion
       * @param {Boolean} promotionApplied true, if the promotion is applied to the order
       * @param {String} level The level for the promotion
       * @param {String} totalAdjustment The adjustment by the promotion
       */
      self.newPromotionInfo = function(promotionId, description, promotionApplied, level, totalAdjustment) {
        var self = {};
        self.promotionId = ko.observable(promotionId?promotionId:'');
        self.promotionDesc = ko.observable(description?description:'');
        self.promotionApplied = ko.observable(promotionApplied?promotionApplied:false);
        self.promotionLevel = ko.observable(level?level:'');
        self.totalAdjustment = ko.observable(totalAdjustment?totalAdjustment:'0');

        self.toJSON = function() {
          var copy = ko.toJS(self);
          return copy;
        };

        return self;
      };

      /**
       * Populates promotionData, for a particular promotionId
       * @param {Object} sourcePromotion the promotion object, used to populate viewmodel data
       * @param {Object} targetPromotion the promotion object, populated by sourcePromotion
       * @param {Boolean} promotionApplied true, if the promotion is applied to the order
       */
      self.populatePromotionData = function(sourcePromotion, targetPromotion, promotionApplied) {
        targetPromotion.promotionDesc(sourcePromotion.promotionDesc);
        targetPromotion.promotionApplied(promotionApplied?promotionApplied:sourcePromotion.promotionApplied);
        targetPromotion.promotionLevel(sourcePromotion.promotionLevel);
        targetPromotion.totalAdjustment(sourcePromotion.totalAdjustment);
      };

      /**
       * Populates coupon data for a particular coupon code
       * @param {Array} List of promotions, for the particular coupon code
       * @param {Boolean} promotionApplied true, if the promotion is applied to the order
       */
      self.populateCouponData = function(sourcePromotions, promotionApplied) {
        var self = this;
        var promosToAdd = ko.observableArray([]);
        var promotionFound = false;
        if(sourcePromotions &amp;&amp; sourcePromotions.length > 0) {
          for(var j = 0; j &lt; sourcePromotions.length; j++) {
            promotionFound = false;
            for(var k = 0; k &lt; self.promotions().length; k++) {
              if(sourcePromotions[j].promotionId == self.promotions()[k].promotionId()) {
                self.populatePromotionData(sourcePromotions[j], self.promotions()[k], promotionApplied);
                promotionFound = true;
                break;
              }
            }
            if(!promotionFound) {
              promosToAdd.push(self.newPromotionInfo(sourcePromotions[j].promotionId,sourcePromotions[j].promotionDesc, 
               promotionApplied?promotionApplied:sourcePromotions[j].promotionApplied, 
               sourcePromotions[j].promotionLevel, sourcePromotions[j].totalAdjustment));
            }
          }
        }
        for(var j = 0; j &lt; promosToAdd().length; j++) {
          self.promotions.push(promosToAdd()[j]);
        }
      };

      self.toJSON = function() {
        var copy = ko.toJS(self);
        return copy;
      };

      if(sourcePromotions &amp;&amp; sourcePromotions.length > 0) {
        self.populateCouponData(sourcePromotions, promotionApplied);
      }
      return self;
    };

    CartViewModel.prototype.events = new Array();

    /**
     * Updates CartItem list with quantity and price info from sourceItems
     *
     * @private
     * @function
     * @property sourceItems list of items with updated quantity and price
     * @property targetItems list of items to be updated
     */
    function updateItems(sourceItems, targetItems, merge, self, data) {
      var reloadCart = false;
      for (var i=0;i&lt;sourceItems.length;i++) {
        var found = false;
        for (var j = 0; targetItems &amp;&amp; j &lt; targetItems().length; j++) {
          if (sourceItems[i].productId == targetItems()[j].productId &amp;&amp; sourceItems[i].catRefId == targetItems()[j].catRefId) {
            targetItems()[j].quantity(sourceItems[i].quantity);
            targetItems()[j].discountInfo(sourceItems[i].discountInfo);
            targetItems()[j].rawTotalPrice(sourceItems[i].rawTotalPrice);
            // If this cartItem becomes a gift, then allow updatableQuantity to be changed
            if (merge || ((targetItems()[j].giftWithPurchaseCommerceItemMarkers &amp;&amp; targetItems()[j].giftWithPurchaseCommerceItemMarkers.length)
                || (sourceItems[i].giftWithPurchaseCommerceItemMarkers &amp;&amp; sourceItems[i].giftWithPurchaseCommerceItemMarkers.length))) {
              targetItems()[j].updatableQuantity(sourceItems[i].quantity);
            }
            targetItems()[j].itemTotal(sourceItems[i].price);
            targetItems()[j].detailedItemPriceInfo(sourceItems[i].detailedItemPriceInfo);
            targetItems()[j].giftWithPurchaseCommerceItemMarkers = sourceItems[i].giftWithPurchaseCommerceItemMarkers;
            targetItems()[j].isGWPChoicesAvaliable(false);
           // Check whether gift choices are available for an selected item
            self.addGiftDataToItem(targetItems()[j], data);
            // giftWithPurchaseSelections should not be sent in the next pricing request
            delete targetItems()[j].giftWithPurchaseSelections;
            found = true;
            break;
          }
        }
        if ((merge || checkForGiftItem(sourceItems[i].discountInfo)) &amp;&amp; !found) {
          var selectedOptions = getSelectedOptions(sourceItems[i]);
          var item = new CartItem(
              sourceItems[i].productId, null, sourceItems[i].quantity, 
              sourceItems[i].catRefId, selectedOptions, 
              CartViewModel.singleInstance.currency, 
              sourceItems[i].discountInfo, sourceItems[i].rawTotalPrice, 
              sourceItems[i].externalPrice, sourceItems[i].externalPriceQuantity);
          item.itemTotal(sourceItems[i].price);
          item.detailedItemPriceInfo(sourceItems[i].detailedItemPriceInfo);
          item.giftWithPurchaseCommerceItemMarkers = sourceItems[i].giftWithPurchaseCommerceItemMarkers;
          // Check whether gift choices are available for an selected item
          self.addGiftDataToItem(item, data);
          targetItems.push(item);
          reloadCart = true;
        }
      }

      for (var j = 0; targetItems &amp;&amp; j &lt; targetItems().length; j++) {
        var found = false;
        for (var i=0; i &lt; sourceItems.length; i++) {
          if (sourceItems[i].productId == targetItems()[j].productId &amp;&amp; sourceItems[i].catRefId == targetItems()[j].catRefId) {
            found = true;
            break;
          }
        }
        if (!found) {
          targetItems.remove(targetItems()[j]);
          // Removing an item from the array on which we are iterating causes problems as the index is incremented
          // but the length decreases. Hence we need to decrement the index, when removing the item.
          j--;
        }
      }
      return reloadCart;
    }

    /**
     * Checks whether the item in the shopping cart is a gift or not
     *
     * @private
     * @function
     * @property item Shopping cart item
     */
    function checkForGiftItem(itemDiscountInfo) {
      if (itemDiscountInfo &amp;&amp; itemDiscountInfo.length) {
        for (var i=0; i &lt; itemDiscountInfo.length; i++) {
          if (itemDiscountInfo[i].giftWithPurchaseDiscountInfo &amp;&amp; itemDiscountInfo[i].giftWithPurchaseDiscountInfo.length) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Helper Model for sending cart info in correct format for getProductsAvailability
     *
     * @private
     * @class Represents cart availability information.
     * @name CartAvailabilityModel
     * @property {CartViewModel} cart
     */
    function CartAvailabilityModel(cart) {
      this.operation= "availability";
      this.products = new Array();
      this.catalogId = cart.catalogId();
      for (var i = 0; i &lt; cart.items().length; i++) {
        var prodSkuCombo = cart.items()[i].productId;
        var skuId = cart.items()[i].catRefId;
        if(skuId)
          prodSkuCombo = prodSkuCombo + ":" + skuId;
        this.products.push(prodSkuCombo);
      }
      this.products = this.products.join(",");
    }

    /**
     * Calls the getProductsAvailability end point and based on the
     * stock status of cart items redirect to checkout or cart
     *
     * @private
     * @function
     * @name CartViewModel#validateCartAvailability
     * @returns {boolean} true if all items in the cart are currently available, otherwise false.
     */
    CartViewModel.prototype.validateCartAvailability = function() {
      var self = this;
      if (self.items().length > 0) {
        var availabilityModel = new CartAvailabilityModel(self);
        self.adapter.loadJSON('getStockStatuses', '0', availabilityModel,
          //success callback
          function(data) {
            self.validateCartForCheckout(data);
          },
          //error callback
          function(data) {
            self.redirect(self.cartLink);
            // As shopper is being redirected to cart page, notify the shopper on that page.
            self.notifyInvalidProducts('cart');
          }
        );
        return false;
      }
      return true;
    };

    /**
     * If stock status of any of cart items is false then redirect to cart
     * else redirect to checkout.
     *
     * @private
     * @function
     * @name CartViewModel#validateCartForCheckout
     * @param {Object} data Updated data returned from server.
     */
    CartViewModel.prototype.validateCartForCheckout = function (data) {
      var self = this;
      for (var i = 0; i &lt; self.items().length; i++) {
        for (var j = 0; j &lt; data.length; j++) {
          if ((self.items()[i].productId === data[j].productId) &amp;&amp; (self.items()[i].catRefId === data[j].catRefId)) {
            if (data[j].stockStatus === 'IN_STOCK') {
              self.items()[i].addLimitsValidation(true, data[j].orderableQuantity);
            } else {
              self.items()[i].addLimitsValidation(false, data[j].orderableQuantity);
            }
            break;
          }
        }
      }

      for (var i = 0; i &lt; self.items().length; i++) {
        for (var j = 0; j &lt; data.length; j++) {
          if ((self.items()[i].productId === data[j].productId) &amp;&amp; (self.items()[i].catRefId === data[j].catRefId)) {
            if (!((data[j].stockStatus === 'IN_STOCK') &amp;&amp; (self.items()[i].quantity() &lt;= data[j].orderableQuantity))) {
              self.redirect(self.cartLink);
              self.checkoutWithPaypalClicked(false);
              return;
            }
           break;
          }
        }
      }
      //everything is fine, redirect to checkout or paypal site
      if (self.checkoutWithPaypalClicked()) {
        self.redirect(ccConstants.PAYPAL_CHECKOUT_TYPE);
      } else {
        self.redirect(self.checkoutLink);
        // As shopper is being redirected to checkout page, notify the shopper on that page.
        self.notifyInvalidProducts('checkout');
      }
    };

    /**
     * Redirect to link that is passed as the parameter
     * and reloads the page from server.
     *
     * @private
     * @function
     * @name CartViewModel#redirect
     * @param {string} link URL to redirect
     */
    CartViewModel.prototype.redirect = function (link) {
      var self = this;
      if (self.validateAndRedirectCart() || ((self.checkoutLink == link || link == ccConstants.PAYPAL_CHECKOUT_TYPE) &amp;&amp; (self.user().loggedIn() || self.user().isUserSessionExpired()))) {
        self.validateAndRedirectCart(false);
        if (link == ccConstants.PAYPAL_CHECKOUT_TYPE) {
          self.user().validateAndRedirectPage(link);
        } else {
          self.user().validateAndRedirectPage(self.checkoutLink);
        }
      } else {
        if (!navigation.isPathEqualTo(link)) {
          if (link == ccConstants.PAYPAL_CHECKOUT_TYPE) {
            $.Topic(pubsub.topicNames.CONTINUE_TO_PAYPAL).publish();
          } else {
            navigation.goTo(link);
          }
        } else {
          //added this line to get the cart data from Server than cache
          self.reloadCart();
        }
      }
    };

    /**
     * Set internal cart context from parameter. Also set cartLink and checkoutLink URIs.
     *
     * @function
     * @name CartViewModel#setContext
     * @param {Object} pContext The context.
     */
    CartViewModel.prototype.setContext = function(pContext) {
      this.contextData = pContext;
      this.cartLink = this.contextData.global.links.cart.route;
      this.checkoutLink = this.contextData.global.links.checkout.route;
      this.isTaxIncluded = this.contextData.global.site.isTaxIncluded;
      this.showTaxSummary = this.contextData.global.site.showTaxSummary;
    };
    
    
    
    /**
     * This updates the values of dynamic properties for the order
     * @private
     * @function
     * @name CartViewModel#validateDynamicProperties
     * @param {Object} data
     */
    CartViewModel.prototype.validateDynamicProperties = function() {
      var self = this;
      for ( var i = 0; i &lt; self.dynamicProperties().length; i++) {
        var dynProp = self.dynamicProperties()[i];
        if (!dynProp.validateNow()) {
          return false;
        }
      }
      return true;
    };

    /**
     * This updates the values of dynamic properties for the order
     * @private
     * @function
     * @name CartViewModel#updateDynamicProperties
     * @param {Object} data Dynamic property values
     */
    CartViewModel.prototype.updateDynamicProperties = function(data) {
      var self = this;
      if (data.dynamicProperties &amp;&amp; self.dynamicProperties) {
        var refreshMetadata = false;
        for (var i = 0; i &lt; data.dynamicProperties.length; i++) {
          var propertyFound = false;
          for (var j = 0; j &lt; self.dynamicProperties().length; j++) {
            if (data.dynamicProperties[i].id === self.dynamicProperties()[j].id()) {
              self.dynamicProperties()[j].value(data.dynamicProperties[i].value);
              propertyFound = true;
              break;
            }
          }
          
          // If property not found then metadata is stale
          // Save ID and value for now
          if (!propertyFound) {
            refreshMetadata = true;
            var dynPropItem = new DynamicProperty();
            dynPropItem.id(data.dynamicProperties[i].id);
            dynPropItem.value(data.dynamicProperties[i].value);
            self.dynamicProperties.push(dynPropItem);
          }
        }
        
        // Refresh the metadata if required
        if (refreshMetadata) {
          self.getDynamicPropertiesMetadata(false);
        }
      }
    };

    /**
     * This adds dynamic properties to the pricing model
     * @private
     * @function
     * @name CartViewModel#populateDynamicProperties
     * @param {Object} pricingModel
     */
    CartViewModel.prototype.populateDynamicProperties = function(pricingModel) {
      var self = this;
      for ( var i = 0; i &lt; self.dynamicProperties().length; i++) {
        var dynPropItem = self.dynamicProperties()[i];
        var dynPropId = dynPropItem.id();
        var dynPropValue = dynPropItem.value();
        pricingModel[dynPropId] = dynPropValue;
      }
    };
    
    /**
     * Gets metadata on custom order properties
     * @private
     * @function
     * @name CartViewModel#getDynamicPropertiesMetadata
     * @param {boolean} pUseCache Whether to use cached metadata
     */
    CartViewModel.prototype.getDynamicPropertiesMetadata = function(pUseCache) {
      var self = this;
      var refreshCache = true;
      
      // Fetch the meta-data from the cache
      if (pUseCache) {
        var cookieData = null;
        try {
          cookieData = self.getStorageItem("cartDynPropsMetadata");
          if (cookieData) {
            cookieData = JSON.parse(cookieData);
            self.processDynamicPropertiesMetadata(cookieData, false);
            refreshCache = false;
          }
        }
        catch(pError) {
        }
      }
      
      // Fetch the metadata from the server
      if (refreshCache) {
        self.adapter.loadJSON('dynamicProperties', 'order', null,
            //success callback
            function(data) {
              // Process the dynamic property metadata
              if (data) {
                self.processDynamicPropertiesMetadata(data, true);
              }
            },
            //error callback
            function(data) {
            }
          );
      }
    };

    /**
     * Processes the dynamic property metadata
     * @private
     * @function
     * @name CartViewModel#processDynamicPropertiesMetadata
     * @param {Object[]} data List of dynamic properties
     * @param {boolean} saveInCache Whether to save dynamic properties to the cache
     */
    CartViewModel.prototype.processDynamicPropertiesMetadata = function(data, saveInCache) {
      var self = this;
      var newProperties = [];
      for (var i = 0; i &lt; data.length; i++) {
        var newProperty = true;
        // If property already defined, update its metadata
        for (var j = 0; j &lt; self.dynamicProperties().length &amp;&amp; newProperty; j++) {
          if (data[i].id === self.dynamicProperties()[j].id()) {
            newProperty = false;
            self.dynamicProperties()[j].initializeMetadata(data[i], false);
          }
        }
        
        // Set up new property
        if (newProperty) {
          var dynPropItem = new DynamicProperty();
          dynPropItem.initializeMetadata(data[i], true);
          newProperties.push(dynPropItem);
        }
      }

      // Add new properties
      for (var i = 0; i &lt; newProperties.length; i++) {
        self.dynamicProperties.push(newProperties[i]);
      }

      // Save metadata to the cache
      if (saveInCache) {
        try {
          var dynPropsMetadata = new Array();
          for (var i = 0; i &lt; self.dynamicProperties().length; i++) {
            dynPropsMetadata.push(self.dynamicProperties()[i].getMetadata());
          }
          var cookieData = JSON.stringify(dynPropsMetadata);
          self.setStorageItem("cartDynPropsMetadata", cookieData, 10800); // expires in 3 hours time
        }
        catch (pError) {
        }
      }
    };
    
    /**
     * Saves the given value to client-side storage using the given key and with the
     * given expiry period
     * @private
     * @function
     * @name CartViewModel#setStorageItem
     * @param {String} name Key associated with storage item that the value will be saved to
     * @param {Object} value The value to be saved
     * @param {number} [expires=3600] Expiry period for the storage item. Defaults to 1 hour
     */
    CartViewModel.prototype.setStorageItem = function(name, value, expires) {
      if (expires === undefined || expires === null) {
        expires = 3600; // default 1 hour
      }
      var date = new Date();
      var expiryTime = Math.round((date.setSeconds(date.getSeconds() + expires)) / 1000);
      
      storageApi.getInstance().setItem(name, value);
      storageApi.getInstance().setItem(name + '_time', expiryTime);
    };
    
    /**
     * Retrieves value from client-side storage for the given key
     * @private
     * @function
     * @name CartViewModel#getStorage
     * @param {String} name Key used to fetch the stored value
     * @returns {Object} The stored object
     */
    CartViewModel.prototype.getStorageItem = function(name) {
      var date = new Date();
      var currentTime = Math.round(date/1000);
      
      // Get value and expiry time
      var value = storageApi.getInstance().getItem(name);
      var storedTime = storageApi.getInstance().getItem(name + '_time');
      if (storedTime === undefined || storedTime === null) {
        storedTime = 0;
      }
      
      // Handle case when the item has expired
      if (storedTime &lt; currentTime) {
        this.removeStorageItem(name);
        return null;
      }
      else {
        return value;
      }
    };
    
    /**
     * Removes the items with the given key from client-side storage
     * @private
     * @function
     * @name CartViewModel#removeStorage
     * @param {String} name Key associated with storage to be removed
     */
    CartViewModel.prototype.removeStorageItem = function(name) {
      storageApi.getInstance().removeItem(name);
      storageApi.getInstance().removeItem(name + '_time');
    };
    

    /**
     * Facilitates the implementers to set callback functions.
     * @function
     * @name CartViewModel#setCallbackFunctions
     * @param {Object} callbackObject object containing keys as different events 
     *     and values as functions to be executed on those events.
     */
    CartViewModel.prototype.setCallbackFunctions = function(callbackObject) {
      var self = this;

      if (callbackObject &amp;&amp; Object.keys(callbackObject) 
          &amp;&amp; Object.keys(callbackObject).length > 0) {
        for (var key in callbackObject) {
          self.callbacks[key] = callbackObject[key];
        }
      }
    };


    /**
     * &lt;p>
     *    Creates the shipping groups array from the ShippingGroupRelationships instances on the cart. The shipping 
     *    groups array is a transient (not saved) object that is only used as a request parameter for web service 
     *    calls (createOrder, priceOder, etc.). Transient means that shipping groups must be generated for every 
     *    service call. This ensures that the most current cart data is also sent in the service request.
     *  &lt;/p>
     *
     * @private
     * @function
     * @name CartViewModel#createShippingGroups
     * @param {Object[]} The shiping groups array generated from the shipping group relationships on the cart.
     */
    CartViewModel.prototype.createShippingGroups = function () {
      var shippingGroups;

      if (this.isSplitShipping()) {
        // Create a shipping groups map (as opposed to array) from the cart.
        //
        // FYI - Building shipping groups as an (intermediate) map avoids duplicate entries.
        var shippingGroupsMap = this.items().reduce(function (targetMap, cartItem) {
          // Convert each shipping goup relationship into a map and merge together to create a single shipping groups map.
          cartItem.shippingGroupRelationships().forEach(function (shippingGroupRelationship) {
            var sourceMap = shippingGroupRelationship.asMap();
            var shippingGroupKey = Object.keys(sourceMap)[0];
            var targetShippingGroup = targetMap[shippingGroupKey];
            var sourceShippingGroup = sourceMap[shippingGroupKey];
            var shippingGroupItemKey = shippingGroupRelationship.catRefId;
            var targetShippingGroupItem = targetShippingGroup ? targetShippingGroup.items[shippingGroupItemKey] : undefined;
            var sourceShippingGroupItem = sourceShippingGroup.items[shippingGroupItemKey];

            // The source shipping group item already exists in the target shipping group.
            if (targetShippingGroupItem) {
              // Update the target quantity.
              targetShippingGroupItem.quantity += sourceShippingGroupItem.quantity;
            }
            else {
              // Merge source map into target  map.
              $.extend(true, targetMap, sourceMap);
            }
          });

          return targetMap;
        }, {});

        // Convert the shipping groups map to the shipping group array.
        shippingGroups = Object.keys(shippingGroupsMap)
          .map(function (key) {
            return shippingGroupsMap[key];
          })
          .filter(function (shippingGroup) {
            // Convert the items map to the items array.
            shippingGroup.items = Object.keys(shippingGroup.items)
              .map(function (key) {
                return shippingGroup.items[key];
              })
              .filter(function (shippingGroupItem) {
                // Only items with quantities are relevant.
                if (shippingGroupItem.quantity > 0) {
                  return shippingGroupItem;
                }
              });

            // Only shipping groups with items are relevant.
            if (shippingGroup.items.length) {
              return shippingGroup;
            }
          });
        }

      return shippingGroups;
    };

    /**
     * Creates a CartItem for the Cart.
     *
     * @private
     * @class Represents a cart item.
     * @name CartItem
     * @property {string} productID Product ID of the current item
     * @property {observable&lt;Object>} productData Product Data associated wtih the current item
     * @property {observable&lt;number>} quantity the number of items
     * @property {string} catRefId SKU id of the item
     * @property {observable&lt;number>} itemTotal Total cost of the item.
     * @property {observable&lt;boolean>} stockStatus Whether the item is current available.
     * @property {observable&lt;number>} updatableQuantity The number of items actually available to purchase after 
     *    adjustments to stock level.
     * @property {observable&lt;number>} rawTotalPrice
     * @property {observableArray&lt;ShippingGroupRelationship>} shippingGroupRelationships The collection of 
     *    ShippingGroupRelationships instances for a this cart item. By default, there is one 
     *    ShippingGroupRelationship instance per cart items, meaning that each cart item will be associated to at 
     *    least one shipping group. 
     */
    function CartItem(pProductId, pProductData, pQuantity, pCatRefId, 
        pSelectedOptions, pCurrency, pDiscountInfo, pRawTotalPrice, 
        pExternalPrice, pExternalPriceQuantity) {
      var self = this;

      self.productId = pProductId;
      self.productData = ko.observable(pProductData);
      self.quantity = ko.observable(pQuantity);
      self.catRefId = pCatRefId;
      self.itemTotal = ko.observable(0);
      self.stockStatus = ko.observable(true);
      self.updatableQuantity = ko.observable(pQuantity);
      self.selectedOptions = pSelectedOptions;
      self.discountInfo = ko.observable(pDiscountInfo);
      self.rawTotalPrice = ko.observable(pRawTotalPrice);
      self.detailedItemPriceInfo = ko.observableArray();
      self.externalPrice = ko.observable(pExternalPrice);
      self.externalPriceQuantity = ko.observable(pExternalPriceQuantity);
      Object.defineProperty(self, 'shippingGroupRelationships', {
        value: ko.observableArray([new ShippingGroupRelationship(self, pQuantity)]).extend({
            validation: [
              {
                validator: function (value) {
                  if (value) {
                    var shippingGroupRelationsQuantitiesSum = value.reduce(function (sum, shippingGroupRelationship) {
                      return sum += parseFloat(shippingGroupRelationship.quantity());
                    }, 0);

                    return !(shippingGroupRelationsQuantitiesSum > self.quantity());
                  }
                },
                message: CCi18n.t('ns.common:resources.quantityAllocationExceeded')
              },
              {
                validator: function (value) {
                  var shippingGroupRelationsQuantitiesSum = value.reduce(function (sum, shippingGroupRelationship) {
                    return sum += parseFloat(shippingGroupRelationship.quantity());
                  }, 0);

                  return !(shippingGroupRelationsQuantitiesSum &lt; self.quantity());
                },
                message: CCi18n.t('ns.common:resources.quantityNotFullyAllocated')
              }]
        }).isModified(true),
        enumerable: false
      });
      
      // When cart item quantity is updated the shipping group realationship quantities will then be out of 
      // synch. and must be reset.
      if(application !== ccConstants.APPLICATION_AGENT) {
        $.Topic(pubsub.topicNames.CART_UPDATE_QUANTITY_SUCCESS).subscribe(self.resetShippingGroupRelationships.bind(self));
      }

      self.invalid = false;
      self.isGWPChoicesAvaliable = ko.observable(false);

      // If gift product, add 'giftWithPurchaseSelections' to the cart item
      if (pProductData &amp;&amp; pProductData.giftProductData) {
        self.giftWithPurchaseSelections = [
          {
            "giftWithPurchaseIdentifier": pProductData.giftProductData.giftWithPurchaseIdentifier,
            "promotionId": pProductData.giftProductData.promotionId,
            "giftWithPurchaseQuantity": pProductData.giftProductData.giftWithPurchaseQuantity
          }
        ];
      }

      self.updatableQuantity.extend ({ required: { params: true, message: CCi18n.t('ns.common:resources.quantityRequireMsg') },
                                        digit: { params: true, message: CCi18n.t('ns.common:resources.quantityNumericMsg') },
                                        trigger: { value: '0', message: CCi18n.t('ns.common:resources.removeItemMsg') }});

      self.originalPrice = ko.observable(0);
      self.currentPrice = ko.observable(0);
      self.priceListGroupId = ko.observable(SiteViewModel.getInstance().selectedPriceListGroup().id);
      self.priceChangedMessage = ko.computed(function() {
        return CCi18n.t('ns.common:resources.productPriceChanged', {originalPrice: currencyHelper.handleFractionalDigits(self.originalPrice(),pCurrency.fractionalDigits),
    	  currency: pCurrency === undefined? '' : pCurrency.symbol});
      });

      self.productPriceChanged = ko.observable(false);
      self.productPriceChanged.extend ({trigger: { value: true, message: self.priceChangedMessage}});

      /**
       * Set the actual item quantity back to the initial quantity.
       *
       * @function
       * @name CartItem#revertQuantity
       */
      self.revertQuantity = function() {
        self.updatableQuantity(self.quantity());
      };

      /**
       * Replace spaces in the give data parameter with dashes.
       *
       * @function
       * @name CartItem.removeSpaces
       * @param {string} data The string to modify.
       * @returns {string} New string with the spaces replaced by dashes.
       */
      self.removeSpaces = function(data) {
        if (data) {
          return data.replace(/\s+/g, '-');
        } else {
          return '';
        }
      };
      
      /**
       * Returns the localized string containing the option name and the option value for a selected option.
       * This function also determines whether or not to append a coma (,) at the end of the string by looping
       * through the selectedOptions array and checks if there is any non-null option value after the selected option.
       * 
       * @function
       * @name CartItem.optionText
       * @param {int} index The index of the selected option.
       * @returns {string} Localized string containing the option name and the option value.
       */
      self.optionText = function(index) {
    	var selectedOption = self.selectedOptions[index];
    	for (var i = index + 1; i &lt; self.selectedOptions.length; i++) {
    	  var nextOption = self.selectedOptions[i];
    	  if (nextOption.optionValue) {
    		return CCi18n.t('ns.common:resources.optionHasNext', {optionName: selectedOption.optionName,
    			optionValue: selectedOption.optionValue});
    	  }
    	}
    	return CCi18n.t('ns.common:resources.optionLast', {optionName: selectedOption.optionName,
			optionValue: selectedOption.optionValue});
      }

      /**
       * Convert an observable object into a plain javascript object (freeze values), and remove fields
       * that aren't relevant to pricing calculations.
       *
       * @function
       * @name CartItem#toJSON
       * @returns {Object} New Object containing cart item data.
       */
      self.toJSON = function() {
        var oldOptions = koMapping.defaultOptions().ignore;
        koMapping.defaultOptions().ignore = ["productData","itemTotal","updatableQuantity","productPriceChanged",
                                             "originalPrice","selectedOptions","priceChangedMessage","isGWPChoicesAvaliable","giftData"];
        var copy = koMapping.toJS(self);
        koMapping.defaultOptions().ignore = oldOptions;
        return copy;
      };

      /**
       * Add validation functions to updatable quantity field to ensure it lies between the maximum orderable
       * quantity and greater than zero, and there is available stock.
       *
       * @private
       * @function
       * @name CartItem#addLimitsValidation
       * @param {boolean} stockStatus Whether the item is in stock.
       * @param {number} orderableQuantity How many of item are available to order.
       */
      self.addLimitsValidation = function(stockStatus, orderableQuantity) {
        self.stockStatus(stockStatus);
        if (orderableQuantity !== null &amp;&amp; !isNaN(orderableQuantity) &amp;&amp; orderableQuantity > 0) {
          var insufficientStockMsg = CCi18n.t('ns.common:resources.insufficientStockMsg', {stockLimit: orderableQuantity});
          self.updatableQuantity.extend({max:{params: orderableQuantity, message: insufficientStockMsg}});
        } else {
          var outOfStockMsg = CCi18n.t('ns.common:resources.outOfStockMsg');
          self.updatableQuantity.extend({max:{params: 0, message: outOfStockMsg}});
        }
        //added this to trigger the validations on load of page.
        self.updatableQuantity.isModified(true);
      };
    }

    /**
     * &lt;p>
     *   Determines if it is possible to add another shipping group relationship instance (i.e. associate/split the 
     *   cart item with another shipping group). The maximum number of shipping group relationship instances is equal 
     *   to the cart item quantity, beyond which it is not possible to split the cart item any further (as there would
     *   be more associations than cart items available).
     * &lt;/p>
     *
     * @function
     * @name CartItem#canAddShippingGroupRelationship
     * @return {boolean} - true if it is possible to add another shipping group relationship instance, false otherwise.
     */
    CartItem.prototype.canAddShippingGroupRelationship = function () {
      // Can have at most this.quantity() shipping group relationships.
      var canAddShippingGroupRelationship = this.quantity() > this.shippingGroupRelationships().length;

      return canAddShippingGroupRelationship;
    };

    /**
     * &lt;p>
     *   In order to ship the same cart item (SKU) to several different addresses (shipping groups), it is necessary
     *   to create several associations (shipping group relationships) between a cart item and shipping group. This 
     *   method creates additional shipping group relationship instances, allowing multiple associations per single 
     *   cart item. The maximum number of shipping group relationship instances is equal to the cart item quantity, 
     *   beyond which it is not possible to split the cart item any further (as there would be more associations than
     *   cart items available).
     * &lt;/p>
     *
     * @function
     * @name CartItem#addShippingGroupRelationship
     */
    CartItem.prototype.addShippingGroupRelationship = function () {
      // Can have at most this.quantity() shipping group relationships.
      if (this.canAddShippingGroupRelationship() &amp;&amp; application !== ccConstants.APPLICATION_AGENT) {
        // Add a new shipping group relationships.
        this.shippingGroupRelationships.push(new ShippingGroupRelationship(this, 1));

        // The sum of the shipping group relationship quantities should equal the cart item quantity. 
        // As a new quantity has been added, the other quantities must be adjusted.
        // 
        // Find the first shiping group with quantity > 1 and decrement by 1.
        var shippingGroupRelationshipForQuantityAdjusment = ko.utils.arrayFirst(this.shippingGroupRelationships(), function (shippingGroupRelationship) {
          return shippingGroupRelationship.quantity() > 1;
        });

        shippingGroupRelationshipForQuantityAdjusment.addQuantity(-1);
      } else if(application === ccConstants.APPLICATION_AGENT) {
        this.shippingGroupRelationships.push(new ShippingGroupRelationship(this, 0));
      }
    };

    /**
     * &lt;p>
     *   Remove a ShippingGroupRelationship instance from the cart item's shippingGroupRelationships array.
     * &lt;/p>
     *
     * @function
     * @name CartItem#removeShippingGroupRelationShip
     * @param {ShippingGroupRelationship} shippingGroupRelationship - The instance to be removed.
     */
    CartItem.prototype.removeShippingGroupRelationShip = function (shippingGroupRelationship) {
      // Must have at least 1 shipping group relationship.
      if (this.shippingGroupRelationships().length > 1) {
        // Remove the shipping group relationship.
        this.shippingGroupRelationships.remove(shippingGroupRelationship);

        // The sum of the shipping group relationship quantities should equal the cart item quantity.
        // As a quantity has been removed that quantity must be redistributed.
        if(application !== ccConstants.APPLICATION_AGENT) {
          var firstShippingGroupRelationship = this.shippingGroupRelationships()[0];

          firstShippingGroupRelationship.addQuantity(shippingGroupRelationship.quantity());
        }
      }
    };

    
    /**
     * &lt;p>
     *   Resets the shippingGroupRelationship array to its initial state. The purpose for this method is as follows.
     *   The quantity of cart item and the sum of the quantities of the associated shipping group relationships must 
     *   be the same. Changes to quantities that cause the values to diverge must be handled.
     * &lt;/p>
     * &lt;ul>
     *   &lt;li>
     *     Scenario 1 - Changes to shipping group relationship quantities that cause a mismatch are handled by form
     *     validation.
     *   &lt;/li>
     *   &lt;li>
     *     Scenario 2 - Changes to the cart item quantity that causes a mismatch must trigger a reset of the shipping 
     *     group relationships array to its initial state.
     *   &lt;/li>
     * &lt;/ul>
     * &lt;p>
     *   This method handle scenario 2.
     * &lt;/p>
     *
     * @private
     * @function
     * @name CartItem#resetShippingGroupRelationships
     */
    CartItem.prototype.resetShippingGroupRelationships = function () {
      // If the cart is modified reset the shipping group relationships to the default state.
      if (this.shippingGroupRelationships().length &lt; 1) {
        this.shippingGroupRelationships(new ShippingGroupRelationship(this, this.quantity()));
      }
      else {
        // Sync the quantity.
        this.shippingGroupRelationships()[0].quantity(this.quantity());
        // Remove all relationship but the first.
        this.shippingGroupRelationships.splice(1, this.shippingGroupRelationships().length);
      }
    };

    /**
     * &lt;p>
     *  The view model class that represents an association between a cart item and a shipping group. Strictly
     *  speaking, ShippingGroupRelationships associates a specified quantity of the cart item with a shipping address
     *  and shipping method (not shipping group), however the shipping groups array is directly generated from the 
     *  ShippingGroupRelationships instances (see the createShippingGroups method). When the user selects a shipping 
     *  address and shipping method for a given cart item, it is this class that captures those selections.
     * &lt;/p>
     *
     * @private
     * @class
     * @name ShippingGroupRelationship
     * @param {CartItem} cartItem - The associated cart item.
     * @param {Number} quantity - The initial quantity of cart item to be associated to the shipping group.
     * @property {ko.observable&lt;Number>} quantity - The quantity of cart item to be associated to the shipping group.
     * @property {ko.observable&lt;Address>} shippingAddress - The address to which this quantity of cart item should be 
     *    shipped.
     * @property {ko.observable&lt;ShippingMethodItemViewModel>} shippingMethod - The method by which this quantity of
     *    cart item should be shipped.
     */
    function ShippingGroupRelationship (cartItem, quantity) {
      // Default args.
      quantity = quantity || 0;

      // Properties.
      this.catRefId = cartItem.catRefId;
      this.productId = cartItem.productId;
      this.quantity = ko.observable(quantity);
      this.shippingOptions = ko.observableArray();
      this.shippingAddress = ko.observable();
      this.shippingMethod = ko.observable();
      if(application === ccConstants.APPLICATION_AGENT) {
        this.updatableQuantity = ko.observable(quantity);
        this.updatableQuantity.extend ({ required: { params: true, message: CCi18n.t('ns.common:resources.quantityRequireMsg') },
            digit: { params: true, message: CCi18n.t('ns.common:resources.quantityNumericMsg') },
            trigger: { value: '0', message: CCi18n.t('ns.common:resources.removeItemMsg') }});
      }
    }

    /**
     * &lt;p>
     *   Generate a unique string key for this instance (see ShippingGroupRelationship#asMap method).
     * &lt;/p>
     *
     * @private
     * @function
     * @name ShippingGroupRelationship#generateKey
     * @return {String} a unique string key for this instance.
     */
    ShippingGroupRelationship.prototype.generateKey = function () {
      var shippingAddress = this.shippingAddress();
      var shippingMethod = this.shippingMethod();
      var key = '';

      if (shippingAddress) {
        key += ko.toJSON(shippingAddress);
      }
      if (shippingMethod) {
        key += ko.toJSON(shippingMethod);
      }

      return key;
    };

    /**
     * &lt;p>
     *   Return a map representation of the ShippingGroupRelationship instance, where a string key (from 
     *   ShippingGroupRelationship#generateKey) maps to this instance. This method is used internally by 
     *   CartViewModel#createShippingGroups in order to map shipping group relationships to shipping groups.
     * &lt;/p>
     *
     * @private
     * @function
     * @name ShippingGroupRelationship#asMap
     * @return {Object} The map representaion of this instance.
     */
    ShippingGroupRelationship.prototype.asMap = function () {
      var shippingGroupMap = {};
      var shippingGroupKey = this.generateKey();
      var shippingGroupItemsMap = {};
      var shippingGroupItemKey = this.catRefId;
      var shippingAddress = ko.toJS(this.shippingAddress());
      var shippingMethod = this.shippingMethod() ? {value: this.shippingMethod().repositoryId} : null;

      // Build shipping group items map.
      shippingGroupItemsMap[shippingGroupItemKey] = {
        productId: this.productId,
        catRefId: this.catRefId,
        quantity: parseFloat(this.quantity(), 10)
      };

      // Build shipping group map.
      shippingGroupMap[shippingGroupKey] = {
        items: shippingGroupItemsMap,
        shippingAddress: shippingAddress,
        shippingMethod: shippingMethod
      };

      return shippingGroupMap;
    };

    /**
     * &lt;p>
     *   Add a specified number to the existing quantity. There is no removeQuantity method as passing negative numbers 
     *   gives the same result.
     * &lt;/p>
     *
     * @private
     * @function
     * @name ShippingGroupRelationship#addQuantity
     * @param {Number} adjustmentAmount - The amount to be added to the quantity (can be negative).
     */
    ShippingGroupRelationship.prototype.addQuantity = function (adjustmentAmount) {
      this.quantity(parseFloat(this.quantity()) + parseFloat(adjustmentAmount));
    };


    /**
     * Helper Model for sending cart info in correct format for pricing.
     *
     * @private
     * @class Represents cart pricing data.
     * @name CartPricingModel
     * @property {CartViewModel} cart The Cart object that needs pricing.
     */
    function CartPricingModel(cart) {
      this.shoppingCart = new Object();
      this.shoppingCart.items = cart.items();
      this.shoppingCart.coupons = cart.coupons();
      if (cart.giftWithPurchaseOrderMarkers &amp;&amp; cart.giftWithPurchaseOrderMarkers.length) {
        this.giftWithPurchaseOrderMarkers = cart.giftWithPurchaseOrderMarkers;
      }
    }

    /**
     * Helper Model for tracking.
     *
     * @private
     * @class Represents a cart event.
     * @name CartEvent
     * @property {string} type, ADD, UPDATE, DELETE
     * @property {number} quantity, the quantity associated with the cart event
     * @property {Object} product, the product data associated with the cart event
     */
    function CartEvent(type, quantity, data) {
      this.type = type;
      this.quantity = quantity;
      if(type == CART_EVENT_COUPON_ADD || type == CART_EVENT_COUPON_DELETE) {
        this.coupon = data;
      } else {
        this.product = data;
      }
    }

    /**
     * Returns the singleton instance of CartViewModel. Create it if it doesn't exist.
     *
     * @param {Object} pAdapter
     * @param {Object} pShoppingCartData
     * @param {Object} pParams some additional params (server data).
     */
    CartViewModel.getInstance = function(pAdapter, pShoppingCartData, pParams, pUser) {
      if(!CartViewModel.singleInstance) {
        CartViewModel.singleInstance = new CartViewModel(pAdapter, pShoppingCartData, pUser, pParams);
        CartViewModel.singleInstance.isPricingRequired(true);
      }

      if(pShoppingCartData &amp;&amp; pShoppingCartData.items) {
        CartViewModel.singleInstance.updatedFromRepository = true;
        CartViewModel.singleInstance.getLocalData(pShoppingCartData);
      }

      if (pParams) {
        CartViewModel.singleInstance.setContext(pParams);
      }

      return CartViewModel.singleInstance;
    };

    /*
     * Sets the application variable.
     * @function
     * @name CartViewModel#setApplication
     * @param {string} pApplication application name.
     */
    CartViewModel.setApplication = function(pApplication) {
      application = pApplication;
    };
    return CartViewModel;
  }

);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-ccKoErrorWrapper.html">ccKoErrorWrapper</a></li><li><a href="module-ccKoExtensions.html">ccKoExtensions</a></li></ul><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="CartViewModel.html">CartViewModel</a></li><li><a href="DynamicProperty.html">DynamicProperty</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="GiftCardViewModel.html">GiftCardViewModel</a></li><li><a href="GiftProductListingViewModel.html">GiftProductListingViewModel</a></li><li><a href="ko.bindingHandlers.background.html">background</a></li><li><a href="ko.bindingHandlers.carouselSwipe.html">carouselSwipe</a></li><li><a href="ko.bindingHandlers.ccForm.html">ccForm</a></li><li><a href="ko.bindingHandlers.ccLink.html">ccLink</a></li><li><a href="ko.bindingHandlers.ccValidation.html">ccValidation</a></li><li><a href="ko.bindingHandlers.checkbox.html">checkbox</a></li><li><a href="ko.bindingHandlers.chosen.html">chosen</a></li><li><a href="ko.bindingHandlers.contextResourcesNamespace.html">contextResourcesNamespace</a></li><li><a href="ko.bindingHandlers.currency.html">currency</a></li><li><a href="ko.bindingHandlers.datepicker.html">datepicker</a></li><li><a href="ko.bindingHandlers.datepopover.html">datepopover</a></li><li><a href="ko.bindingHandlers.draggable.html">draggable</a></li><li><a href="ko.bindingHandlers.droppable.html">droppable</a></li><li><a href="ko.bindingHandlers.fade.html">fade</a></li><li><a href="ko.bindingHandlers.hover.html">hover</a></li><li><a href="ko.bindingHandlers.imageSource.html">imageSource</a></li><li><a href="ko.bindingHandlers.imageZoom.html">imageZoom</a></li><li><a href="ko.bindingHandlers.localeText.html">localeText</a></li><li><a href="ko.bindingHandlers.makeAccess.html">makeAccess</a></li><li><a href="ko.bindingHandlers.modal.html">modal</a></li><li><a href="ko.bindingHandlers.modalTabbingContraint.html">modalTabbingContraint</a></li><li><a href="ko.bindingHandlers.onRender.html">onRender</a></li><li><a href="ko.bindingHandlers.popeditor.html">popeditor</a></li><li><a href="ko.bindingHandlers.popover.html">popover</a></li><li><a href="ko.bindingHandlers.productImageSource.html">productImageSource</a></li><li><a href="ko.bindingHandlers.propertyEditor.html">propertyEditor</a></li><li><a href="ko.bindingHandlers.radio.html">radio</a></li><li><a href="ko.bindingHandlers.richTextEditor.html">richTextEditor</a></li><li><a href="ko.bindingHandlers.scrollAffix.html">scrollAffix</a></li><li><a href="ko.bindingHandlers.select2.html">select2</a></li><li><a href="ko.bindingHandlers.select2Tags.html">select2Tags</a></li><li><a href="ko.bindingHandlers.selectable.html">selectable</a></li><li><a href="ko.bindingHandlers.slickList.html">slickList</a></li><li><a href="ko.bindingHandlers.slide.html">slide</a></li><li><a href="ko.bindingHandlers.slider.html">slider</a></li><li><a href="ko.bindingHandlers.spectrum.html">spectrum</a></li><li><a href="ko.bindingHandlers.tagsInput.html">tagsInput</a></li><li><a href="ko.bindingHandlers.textCheck.html">textCheck</a></li><li><a href="ko.bindingHandlers.timepicker.html">timepicker</a></li><li><a href="ko.bindingHandlers.triggerMessage.html">triggerMessage</a></li><li><a href="ko.bindingHandlers.validatableTarget.html">validatableTarget</a></li><li><a href="ko.bindingHandlers.validatableValue.html">validatableValue</a></li><li><a href="ko.bindingHandlers.widgetLocaleText.html">widgetLocaleText</a></li><li><a href="koValidation.alphaNumeric.html">alphaNumeric</a></li><li><a href="koValidation.alphaNumericNoSpaces.html">alphaNumericNoSpaces</a></li><li><a href="koValidation.alphaNumericNoSpacesWithSeperators.html">alphaNumericNoSpacesWithSeperators</a></li><li><a href="koValidation.alphaNumericWithSeperators.html">alphaNumericWithSeperators</a></li><li><a href="koValidation.bool.html">bool</a></li><li><a href="koValidation.creditcard.html">creditcard</a></li><li><a href="koValidation.cvv.html">cvv</a></li><li><a href="koValidation.endmonth.html">endmonth</a></li><li><a href="koValidation.endyear.html">endyear</a></li><li><a href="koValidation.importFileName.html">importFileName</a></li><li><a href="koValidation.laterDate.html">laterDate</a></li><li><a href="koValidation.match.html">match</a></li><li><a href="koValidation.mediaZipFileName.html">mediaZipFileName</a></li><li><a href="koValidation.number.html">number</a></li><li><a href="koValidation.observablePattern.html">observablePattern</a></li><li><a href="koValidation.password.html">password</a></li><li><a href="koValidation.price.html">price</a></li><li><a href="koValidation.propertyIdAlreadyInUse.html">propertyIdAlreadyInUse</a></li><li><a href="koValidation.propertyNameAlreadyInUse.html">propertyNameAlreadyInUse</a></li><li><a href="koValidation.restrictSlashCharacters.html">restrictSlashCharacters</a></li><li><a href="koValidation.startmonth.html">startmonth</a></li><li><a href="koValidation.startyear.html">startyear</a></li><li><a href="koValidation.uniqueTrimmed.html">uniqueTrimmed</a></li><li><a href="koValidation.uniqueTrimmedCaseInsensitive.html">uniqueTrimmedCaseInsensitive</a></li><li><a href="koValidation.url.html">url</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.addTemplate.html">addTemplate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDate.html">ccDate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDateTime.html">ccDateTime</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccNumber.html">ccNumber</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.disabled.html">disabled</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.element.html">element</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.embeddedAssistance.html">embeddedAssistance</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.inTabFlow.html">inTabFlow</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.setContextVariable.html">setContextVariable</a></li><li><a href="NavStateViewModel.html">NavStateViewModel</a></li><li><a href="OrderHistoryViewModel.html">OrderHistoryViewModel</a></li><li><a href="OrderViewModel.html">OrderViewModel</a></li><li><a href="ParentOrganisation.html">ParentOrganisation</a></li><li><a href="ProductListingSearchViewModel.html">ProductListingSearchViewModel</a></li><li><a href="ProductListingViewModel.html">ProductListingViewModel</a></li><li><a href="ProductViewModel.html">ProductViewModel</a></li><li><a href="PubSub.topicNames.html">topicNames</a></li><li><a href="resetCVV.html">resetCVV</a></li><li><a href="resetPaymentDetails.html">resetPaymentDetails</a></li><li><a href="SearchRestClient.html">SearchRestClient</a></li><li><a href="UserViewModel.html">UserViewModel</a></li><li><a href="WidgetViewModel.html">WidgetViewModel</a></li><li><a href="WishlistContentViewModel.html">WishlistContentViewModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="ko.bindingHandlers.html">bindingHandlers</a></li><li><a href="ko.extenders.html">extenders</a></li><li><a href="koValidation.html">koValidation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CCEETagProcessor">CCEETagProcessor</a></li><li><a href="global.html#isValidDeterminewhetherornotthepaymentdetailsobjectisvalidbasedonthevalidityofitscomponentparts.Thiswillnotcauseerrormessagestobedisplayedforanyobservablevaluesthatareunchangedandhaveneverreceivedfocusontherelatedformfield(s).">isValid
Determine whether or not the payment details object is valid
based on the validity of its component parts. This will not
cause error messages to be displayed for any observable values
that are unchanged and have never received focus on the 
related form field(s).</a></li><li><a href="global.html#validatePaymentDetailsForceallrelevantmemberobservablestoperformtheirvalidationnow&displaytheerrors(ifany)">validatePaymentDetails
Force all relevant member observables to perform their
validation now & display the errors (if any)</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Mon Oct 10 2016 10:49:02 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
